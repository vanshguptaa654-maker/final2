<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Customer Food Ordering</title>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        /* Base styles for the entire page */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa; /* Lighter background */
            color: #343a40; /* Darker text for better readability */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            line-height: 1.6;
            scroll-behavior: smooth; /* Smooth scrolling for anchor links */
        }

        /* Header styling */
        header {
            background-color: #007bff; /* Primary blue for header */
            color: #fff;
            padding: 20px 0;
            width: 100%;
            text-align: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.15); /* More prominent shadow */
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        header h1 {
            margin: 0;
            font-size: 2.2em; /* Slightly larger heading */
        }

        /* Main content area */
        main {
            padding: 20px;
            width: 100%;
            max-width: 1200px;
            box-sizing: border-box;
            flex-grow: 1;
        }

        /* Common card styles for different sections */
        .app-section {
            background-color: #fff;
            padding: 30px;
            border-radius: 12px; /* More rounded corners */
            box-shadow: 0 6px 20px rgba(0,0,0,0.1); /* Softer, larger shadow */
            margin-top: 25px; /* More vertical space between sections */
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            box-sizing: border-box;
            border: 1px solid #e9ecef; /* Subtle border */
        }

        /* Headings within sections */
        .app-section h2 {
            color: #007bff;
            margin-bottom: 25px; /* More space below heading */
            font-size: 2em; /* Larger headings */
            font-weight: 700; /* Bolder */
        }

        /* Common input styles */
        input[type="text"], input[type="number"], textarea, select, input[type="email"] {
            padding: 12px 15px; /* More padding for inputs */
            margin: 10px 0;
            border: 1px solid #ced4da; /* Lighter border */
            border-radius: 8px;
            width: 80%;
            max-width: 350px; /* Slightly wider inputs */
            box-sizing: border-box;
            font-size: 1.05em;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        input[type="text"]:focus, input[type="number"]:focus, textarea:focus, select[type="email"]:focus {
            border-color: #007bff;
            box-shadow: 0 0 0 0.25rem rgba(0,123,255,.25); /* Focus glow */
            outline: none;
        }

        /* Common button styles */
        button {
            background-color: #007bff;
            color: white;
            padding: 14px 25px; /* Larger buttons */
            border: none;
            border-radius: 8-px;
            cursor: pointer;
            font-size: 17px;
            margin-top: 15px; /* More space above buttons */
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,123,255,0.2); /* Subtle shadow for buttons */
        }

        button:hover:not(:disabled) {
            background-color: #0056b3;
            transform: translateY(-3px); /* More pronounced hover effect */
            box-shadow: 0 6px 15px rgba(0,123,255,0.3);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0,123,255,0.2);
        }

        button:disabled {
            background-color: #e9ecef; /* Lighter disabled background */
            color: #6c757d; /* Greyed out text */
            cursor: not-allowed;
            opacity: 0.9;
            box-shadow: none;
            transform: none;
        }

        /* Error message styling */
        .error-message {
            color: #dc3545;
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 12px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
            width: 100%;
            max-width: 500px;
            box-sizing: border-box;
            text-align: left;
            font-size: 0.95em;
        }
        
        /* Instruction message styling */
        .instruction-message {
            color: #0056b3;
            background-color: #e0f7fa; /* Lighter blue background */
            border-color: #81d4fa; /* Matching border color */
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            width: 100%;
            max-width: 550px; /* Wider instruction messages */
            box-sizing: border-box;
            text-align: left;
            font-size: 1em;
            box-shadow: 0 2px 8px rgba(0, 172, 193, 0.1); /* Subtle shadow */
        }
        
        /* Container for side-by-side instructions */
        #instructionContainer {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            width: 100%;
            margin-bottom: 25px; /* More space below instructions */
        }
        #instructionContainer .instruction-message {
            flex: 1;
            min-width: 300px; /* Min width for readability */
            max-width: 48%; /* Max width for two columns */
            margin-top: 0;
        }

        /* Filter section layout */
        #filters {
            display: flex;
            flex-wrap: wrap;
            gap: 20px; /* More space between filters */
            margin-bottom: 30px;
            justify-content: center;
            padding: 20px;
            background-color: #f1f3f5; /* Slightly darker filter background */
            border-radius: 10px;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.08); /* More defined inner shadow */
            align-items: center;
        }

        #filters label {
            font-weight: bold;
            color: #495057; /* Darker label color */
            white-space: nowrap;
            font-size: 1.05em;
        }

        #filters input[type="text"], #filters select {
            width: auto;
            min-width: 180px; /* Slightly larger filter inputs */
            margin: 0;
            flex-grow: 1;
        }

        /* Carousel container for horizontal scrolling of items */
        .items-carousel-container {
            position: relative;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
            padding: 0 50px; /* Padding for carousel buttons */
            box-sizing: border-box;
        }

        /* Styling for the list of items inside the carousel */
        #itemsList {
            display: flex;
            overflow-x: scroll; /* Enable horizontal scrolling */
            scroll-snap-type: x mandatory; /* Snap to item boundaries */
            scroll-behavior: smooth; /* Smooth scrolling */
            -webkit-overflow-scrolling: touch; /* Enhance touch scrolling on iOS */
            width: 100%; /* Full width */
            padding: 20px 0;
            gap: 30px; /* More space between items */
            box-sizing: border-box;
            scrollbar-width: none; /* Hide scrollbar for Firefox */
            -ms-overflow-style: none; /* Hide scrollbar for IE/Edge */
            margin: 0 auto; /* Center the list */
        }

        /* Hide scrollbar for Webkit browsers (Chrome, Safari) */
        #itemsList::-webkit-scrollbar {
            display: none;
        }

        /* Carousel navigation buttons */
        .carousel-nav-button {
            background-color: rgba(0,123,255,0.8); /* Slightly transparent blue */
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px; /* Larger buttons */
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em; /* Larger icons */
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.25); /* More visible shadow */
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            z-index: 500;
        }

        .carousel-nav-button:hover:not(:disabled) {
            background-color: #0056b3;
            transform: translateY(-50%) scale(1.1); /* More pronounced hover effect */
            box-shadow: 0 6px 15px rgba(0,123,255,0.35);
        }

        .carousel-nav-button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0,123,255,0.2);
        }

        .carousel-nav-button.prev {
            left: 0px; /* Align to the edge of the container */
        }

        .carousel-nav-button.next {
            right: 0px; /* Align to the edge of the container */
        }

        /* --- Item Card Flip CSS --- */
        .item-card {
            flex-shrink: 0;
            width: 90%; /* Start with a large width for mobile responsiveness */
            max-width: 650px; /* Max width for desktop */
            min-height: 480px; /* Increased minimum height for consistent size */
            perspective: 1000px;
            transform-style: preserve-3d;
            transition: transform 0.7s cubic-bezier(0.4, 0.2, 0.2, 1.0); /* Slightly slower and smoother flip */
            border-radius: 15px; /* More rounded card corners */
            box-shadow: 0 8px 25px rgba(0,0,0,0.15); /* Softer, larger shadow */
            position: relative;
            background-color: #fff;
            outline: 1px solid rgba(0,0,0,0.08); /* More visible outline */
            scroll-snap-align: center;
            box-sizing: border-box;
            will-change: transform;
            cursor: grab; /* Indicate draggable content */
            padding: 25px; /* Base padding for the card */
        }
        .item-card:active {
            cursor: grabbing;
        }

        /* When the card is "flipped" (parent rotates) */
        .item-card.flipped-feedback,
        .item-card.flipped-description {
            transform: rotateY(180deg);
        }

        /* Individual faces of the card (front, feedback back, description back) */
        .front, .back-feedback, .back-description {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            border-radius: 15px; /* Match parent border-radius */
            box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.05); /* Inner border-like shadow */
            padding: 25px; /* More internal padding */
            box-sizing: border-box;
            background-color: #fff;
            color: #343a40;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            transition: opacity 0.7s ease-in-out; /* Match flip transition speed */
        }

        /* Front face: initially visible */
        .front {
            transform: rotateY(0deg);
            opacity: 1;
            z-index: 2;
            /* Changed to row for image and info side-by-side */
            flex-direction: row; 
            align-items: flex-start; /* Align to the top of the row */
            gap: 20px; /* Gap between image and info */
            flex-wrap: nowrap; /* Prevent wrapping in desktop view for consistent layout */
        }

        /* Back faces: initially hidden (rotated 180deg relative to parent) */
        .back-feedback, .back-description {
            transform: rotateY(180deg);
            opacity: 0;
            z-index: 1;
            align-items: stretch; /* Stretch content within back faces */
        }

        /* When .item-card is flipped to show feedback */
        .item-card.flipped-feedback > .front {
            opacity: 0;
        }
        .item-card.flipped-feedback > .back-feedback {
            opacity: 1;
            background-color: #f8f9fa; /* Lighter background for feedback side */
            z-index: 3;
        }
        .item-card.flipped-feedback > .back-description {
            opacity: 0;
        }

        /* When .item-card is flipped to show description */
        .item-card.flipped-description > .front {
            opacity: 0;
        }
        .item-card.flipped-description > .back-description {
            opacity: 1;
            background-color: #e9f5ff; /* Light blue background for description side */
            z-index: 3;
        }
        .item-card.flipped-description > .back-feedback {
            opacity: 0;
        }

        /* Internal flip for past-feedback-display-area and feedback-input-area */
        .past-feedback-display-area,
        .feedback-input-area {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: space-between;
            box-sizing: border-box;
            padding: 20px; /* Internal padding for these sub-faces */
            position: absolute;
            top: 0;
            left: 0;
            background-color: inherit; /* Inherit from parent back-feedback/description */
            border-radius: 12px; /* Match card border radius */
            box-shadow: none; /* No additional shadow for internal faces */
            transition: transform 0.6s cubic-bezier(0.4, 0.2, 0.2, 1.0);
            will-change: transform;
            pointer-events: auto;
        }

        .past-feedback-display-area {
            transform: rotateY(0deg);
            z-index: 2;
            opacity: 1;
        }

        .feedback-input-area {
            transform: rotateY(180deg);
            z-index: 1;
            background-color: #f0f8ff; /* Even lighter blue for feedback input */
            align-items: center;
            opacity: 0;
        }

        /* When .back-feedback has show-input-face, flip internal faces */
        .back-feedback.show-input-face .past-feedback-display-area {
            transform: rotateY(-180deg);
            z-index: 1;
            opacity: 0;
        }

        .back-feedback.show-input-face .feedback-input-area {
            transform: rotateY(0deg);
            z-index: 2;
            opacity: 1;
        }

        /* Styles for when an item card is selected (checkbox checked) */
        .item-card.selected {
            border-color: transparent;
            box-shadow: 0 8px 30px rgba(0,0,0,0.25), 0 0 0 4px #28a745; /* Green outline for selected */
        }

        /* Item details and checkbox layout */
        .item-details-label {
            display: flex;
            flex-direction: row;
            align-items: center;
            cursor: pointer;
            flex-grow: 1;
            padding: 0;
            width: 100%;
            box-sizing: border-box;
            position: relative;
        }

        .item-details-label input[type="checkbox"] {
            position: absolute;
            top: -15px; /* Move up relative to card padding */
            left: -15px; /* Move left relative to card padding */
            z-index: 10;
            width: 24px; /* Larger checkbox */
            height: 24px;
            cursor: pointer;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border: 2px solid #007bff;
            border-radius: 6px; /* Slightly more rounded checkbox */
            background-color: #fff;
            transition: background-color 0.2s, border-color 0.2s;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .item-details-label input[type="checkbox"]:checked {
            background-color: #28a745; /* Green when checked */
            border-color: #28a745;
        }

        .item-details-label input[type="checkbox"]:checked::after {
            content: '✔';
            font-size: 16px; /* Larger checkmark */
            color: #fff;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* Item image styling */
        .item-image-container {
            flex-shrink: 0;
            width: 180px; /* Adjusted image size to match reference */
            height: 180px; /* Adjusted image size to match reference */
            border-radius: 10px;
            overflow: hidden;
            border: 1px solid #e9ecef;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .item-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Item information section */
        .item-info {
            flex-grow: 1;
            text-align: left;
            padding-right: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            min-width: 250px; /* Ensure info block has min-width */
            padding-top: 15px; /* Adjust top padding to align with image */
        }

        .item-info h3 {
            margin-top: 0;
            margin-bottom: 5px; /* More space below item name */
            color: #007bff;
            font-size: 1.6em; /* Larger item name */
            font-weight: 600;
        }

        .item-info p {
            margin: 3px 0; /* More space between paragraphs */
            font-size: 1em; /* Slightly larger text */
            text-align: left;
            color: #495057;
        }
        .item-info .original-price {
            text-decoration: line-through;
            color: #888;
            font-size: 0.95em;
            margin-right: 8px;
        }
        .item-info .discounted-price {
            color: #dc3545; /* Red for discounted price */
            font-weight: bold;
            font-size: 1.1em;
        }
        .item-info .final-price-display {
            color: #007bff;
            font-weight: bold;
            margin-top: 5px;
            font-size: 1.1em;
            display: flex;
            align-items: baseline;
            gap: 5px;
        }

        /* Discount badge */
        .discount-badge {
            background-color: #ffc107; /* Amber for discount */
            color: #343a40;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: bold;
            white-space: nowrap;
            display: inline-block;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
        }

        .discount-top-right {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 5;
        }

        /* Quantity control section */
        .quantity-control {
            display: flex;
            align-items: center;
            gap: 12px; /* More space between quantity elements */
            margin-top: 15px;
            width: 100%;
            justify-content: flex-start;
        }

        .quantity-input {
            width: 80px; /* Wider input for quantity */
            text-align: center;
            margin: 0;
            background-color: #f8f9fa; /* Light background for quantity input */
            border-radius: 6px;
        }

        .quantity-control .unit-select {
            padding: 10px; /* More padding for unit select */
            margin: 0;
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-size: 0.95em;
            width: auto;
            min-width: 90px;
            max-width: 140px;
            box-sizing: border-box;
            background-color: #f8f9fa;
        }

        .item-card-subtotal {
            font-weight: bold;
            color: #007bff;
            margin-top: 10px; /* More space above subtotal */
            font-size: 1.2em; /* Larger subtotal */
            text-align: left;
        }

        /* Action buttons within the card (Show Feedback, Show Description) */
        .card-action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px; /* More space between buttons */
            margin-top: 20px; /* More space above buttons */
            align-items: flex-start; /* Aligned to start to match image */
            width: 100%;
        }

        .card-action-buttons button {
            width: auto;
            padding: 10px 18px; /* Slightly larger padding for these buttons */
            font-size: 1em;
            margin: 0;
            align-self: flex-start; /* Aligned to start to match image */
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,123,255,0.1);
        }

        /* Adjust button container for centering when inside feedback display area */
        .past-feedback-display-area .card-action-buttons,
        .back-description .card-action-buttons {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            gap: 20px; /* More space between buttons */
            width: 100%;
            margin-top: 25px;
            padding: 10px 0;
            flex-wrap: wrap; /* Allow wrapping */
        }

        .past-feedback-display-area .card-action-buttons button,
        .back-description .card-action-buttons button {
            margin: 0;
            flex-grow: 0;
            min-width: 140px; /* Ensure minimum width */
            align-self: center;
        }

        /* Feedback input section buttons */
        .feedback-buttons-row {
            display: flex;
            justify-content: center;
            gap: 12px; /* More space between buttons */
            margin-top: 20px;
            width: 100%;
            max-width: 400px;
            flex-wrap: wrap;
        }

        .feedback-buttons-row button {
            flex-grow: 1;
            width: auto;
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            background-color: #ced4da; /* Neutral grey for feedback buttons */
            color: #343a40;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s ease, box-shadow 0.2s ease, transform 0.1s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-width: 90px;
        }

        .feedback-buttons-row button:hover {
            background-color: #adb5bd;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            transform: translateY(-2px);
        }

        /* Headings for feedback and description sections */
        .feedback-input-section h4, .description-section h4 {
            color: #007bff;
            margin-top: 0;
            margin-bottom: 0;
            font-size: 1.1em;
            font-weight: 600;
        }
        .feedback-input-section h4 {
            margin-top: 0;
            padding-top: 0px;
            text-align: center;
            font-size: 1.2em;
            color: #343a40;
        }

        /* Feedback textarea input */
        .feedback-input {
            width: 95%; /* Wider feedback input */
            max-width: 450px;
            margin: 15px auto 15px auto; /* More vertical margin */
            resize: vertical;
            min-height: 100px; /* Taller textarea */
            border-radius: 10px;
            padding: 15px;
            box-sizing: border-box;
            border: 1px solid #ced4da;
            box-shadow: inset 0 1px 4px rgba(0,0,0,0.08);
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .feedback-input:focus {
            border-color: #007bff;
            box-shadow: inset 0 1px 4px rgba(0,0,0,0.08), 0 0 0 4px rgba(0,123,255,0.2); /* More prominent focus glow */
            outline: none;
        }

        /* Like button toggle state */
        .like-button {
            background-color: #28a745; /* Green for like */
            color: white;
        }

        .like-button.liked {
            background-color: #6c757d; /* Grey when liked (toggled off) */
            color: white;
        }

        /* Star rating component */
        .star-rating {
            display: flex;
            flex-direction: row-reverse;
            justify-content: center;
            margin-bottom: 10px;
            align-self: center;
            margin-top: 20px;
        }
        .star-rating input[type="radio"] {
            display: none;
        }
        .star-rating label {
            font-size: 3em; /* Larger stars */
            color: #e9ecef; /* Lighter grey for default stars */
            cursor: pointer;
            transition: color 0.2s, transform 0.1s ease;
            margin: 0 5px; /* More space between stars */
        }
        .star-rating label:hover {
            transform: scale(1.15); /* More pronounced hover */
        }

        .star-rating input[type="radio"]:checked ~ label,
        .star-rating label:hover,
        .star-rating label:hover ~ label {
            color: #ffc107; /* Gold for selected/hovered stars */
        }

        /* Submit feedback button */
        .submit-feedback-button {
            background-color: #007bff;
            color: white;
        }

        /* Past feedbacks display section */
        .past-feedbacks-section {
            width: 100%;
            text-align: left;
            margin-top: 15px;
            padding-top: 0;
            max-height: 250px; /* Slightly taller */
            overflow-y: auto;
            -webkit-scrollbar-width: none;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding-right: 0;
            box-sizing: border-box;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6; /* Lighter border */
            padding: 20px;
            flex-grow: 1;
        }

        .past-feedbacks-section::-webkit-scrollbar {
            display: none;
        }

        .past-feedbacks-section h5 {
            font-size: 1.2em;
            color: #555;
            margin-bottom: 15px;
            text-align: center;
            font-weight: 600;
        }

        .past-feedback-item {
            background-color: #fff;
            border: 1px solid #e9ecef;
            padding: 15px;
            margin-bottom: 12px;
            font-size: 0.9em;
            line-height: 1.6;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .past-feedback-item p {
            margin: 0 0 8px 0;
        }

        .past-feedback-item strong {
            color: #343a40;
        }

        .past-feedback-item .feedback-date {
            font-size: 0.8em;
            color: #888;
            text-align: right;
            display: block;
            margin-top: 5px;
        }

        /* Description content styling */
        .description-content {
            width: 95%;
            text-align: left;
            font-size: 1.05em;
            line-height: 1.7; /* Increased line height for readability */
            margin-bottom: 25px;
            flex-grow: 1;
            padding: 10px 0;
            color: #495057;
        }
        .average-rating {
            display: flex;
            align-items: center;
            gap: 8px; /* More space */
            margin-top: 8px;
        }

        /* Star styling for average rating display */
        .stars-outer {
            display: inline-block;
            position: relative;
            font-family: 'Font Awesome 5 Free';
            font-weight: 900;
            letter-spacing: 3px; /* More spacing for display stars */
            overflow: hidden;
            color: #ced4da; /* Lighter grey for outer stars */
            white-space: nowrap;
        }

        .stars-outer::before {
            content: '\f005 \f005 \f005 \f005 \f005';
        }

        .stars-inner {
            position: absolute;
            top: 0;
            left: 0;
            white-space: nowrap;
            overflow: hidden;
            color: gold;
        }

        .stars-inner::before {
            content: '\f005 \f005 \f005 \f005 \f005';
        }

        /* Order summary list styling */
        #orderSummary ul {
            list-style: none;
            padding: 0;
            width: 100%;
            max-width: 700px; /* Wider order summary list */
        }

        #orderSummary ul li {
            background-color: #f8f9fa; /* Lighter background for list items */
            border: 1px solid #e9ecef;
            padding: 15px 20px; /* More padding */
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            font-size: 1.15em; /* Slightly larger text */
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        #orderSummary ul li span {
            flex: 1;
            min-width: 120px; /* Adjust min-width */
            margin-bottom: 5px;
            color: #343a40;
        }
        #orderSummary ul li span:last-child {
            margin-bottom: 0;
            text-align: right;
            font-weight: bold;
            color: #007bff;
        }

        #orderTotalDisplay {
            font-size: 2.2em; /* Larger total display */
            font-weight: bold;
            margin-top: 25px;
            color: #28a745; /* Green for total */
        }

        .checkout-buttons {
            margin-top: 25px;
            display: flex;
            gap: 20px; /* More space between checkout buttons */
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Final order details section */
        #finalOrderDetails p {
            font-size: 1.15em;
            margin-bottom: 10px;
            color: #495057;
        }
        #finalOrderDetails ul {
            list-style: decimal;
            padding-left: 25px;
            text-align: left;
            width: 100%;
            max-width: 650px;
        }
        #finalOrderDetails ul li {
            margin-bottom: 8px;
            font-size: 1.05em;
            color: #343a40;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5); /* Darker overlay */
            justify-content: center;
            align-items: center;
            padding: 20px; /* Ensure padding on very small screens */
            box-sizing: border-box;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 30px; /* More padding */
            border: 1px solid #dee2e6;
            width: 90%;
            max-width: 650px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.25);
            position: relative;
            animation: fadeInScale 0.3s ease-out; /* Add animation */
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .close-button {
            color: #6c757d; /* Softer close button color */
            float: right;
            font-size: 30px; /* Larger close button */
            font-weight: bold;
            position: absolute;
            top: 15px;
            right: 20px;
            cursor: pointer;
            transition: color 0.2s;
        }

        .close-button:hover,
        .close-button:focus {
            color: #343a40;
        }

        .feedback-list {
            list-style: none;
            padding: 0;
            max-height: 450px; /* Taller feedback list */
            overflow-y: auto;
            margin-top: 20px;
        }

        .feedback-list li {
            background-color: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.05);
        }

        .feedback-list li:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        /* Payment method section */
        .payment-method-section {
            margin-top: 25px;
            width: 100%;
            max-width: 450px; /* Wider payment section */
            text-align: center;
        }

        .payment-method-section label {
            font-weight: bold;
            margin-bottom: 15px;
            display: block;
            font-size: 1.1em;
            color: #343a40;
        }

        .payment-method-section select {
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #ced4da;
            width: 100%;
            font-size: 1.05em;
            background-color: #fefefe;
        }
        #upiDetailsSection, #qrDetailsSection {
            margin-top: 25px;
            padding: 20px;
            border: 1px solid #007bff;
            border-radius: 10px;
            background-color: #e6f7ff;
            box-shadow: 0 4px 12px rgba(0,123,255,0.1);
        }

        .small-button {
            padding: 10px 18px;
            font-size: 0.95em;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
            color: white;
            border: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .small-button:hover {
            opacity: 0.95;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
        }

        .upi-app-button {
            padding: 14px 22px;
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            flex-grow: 1;
            max-width: 200px;
            font-size: 1em;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .upi-app-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
        }

        #payWithPhonePe {
            background-color: #6739B7; /* PhonePe purple */
        }

        #payWithGPay {
            background-color: #DB4437; /* GPay red */
        }
        #payWithPaytm {
            background-color: #00B1EE; /* Paytm blue */
        }

        /* Receipt Modal Specific Styles */
        #receiptContent {
            text-align: left;
            padding: 20px;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            background-color: #fcfcfc;
            box-shadow: inset 0 1px 5px rgba(0,0,0,0.05);
        }
        #receiptContent h3 {
            color: #007bff;
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            font-size: 1.5em;
            font-weight: 700;
        }
        #receiptContent p {
            margin: 8px 0;
            font-size: 1em;
            color: #343a40;
        }
        #receiptContent ul {
            list-style: none;
            padding: 0;
            margin-top: 20px;
        }
        #receiptContent ul li {
            padding: 8px 0;
            border-bottom: 1px dashed #ced4da;
            font-size: 0.95em;
            color: #495057;
        }
        #receiptContent ul li:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        #receiptContent .receipt-total {
            font-size: 1.4em;
            font-weight: bold;
            text-align: right;
            margin-top: 20px;
            color: #28a745;
        }

        /* Styles for tags */
        .item-tags-container {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: flex-start;
        }

        .tag-badge {
            background-color: #e9ecef; /* Light grey for tags */
            color: #495057;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 0.85em;
            font-weight: 500;
            white-space: nowrap;
            display: inline-block;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        /* Desktop Mode Prompt Modal Styles */
        #mobilePromptModal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #mobilePromptModal .modal-content {
            background-color: #fff;
            padding: 35px;
            border-radius: 15px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.4);
            text-align: center;
            max-width: 500px;
            width: 90%;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        #mobilePromptModal h2 {
            color: #007bff;
            margin-bottom: 0;
            font-size: 1.8em;
            font-weight: 700;
        }

        #mobilePromptModal p {
            margin-top: 10px;
            font-size: 1.2em;
            line-height: 1.5;
            color: #555;
        }

        #mobilePromptModal .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 25px;
        }

        #mobilePromptModal button {
            padding: 14px 30px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        #mobilePromptModal #switchToDesktopButton {
            background-color: #28a745;
            color: white;
        }

        #mobilePromptModal #switchToDesktopButton:hover {
            background-color: #218838;
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0,0,0,0.2);
        }

        /* Media queries for responsiveness */
        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
            }
            .app-section {
                padding: 20px;
                margin-top: 15px;
            }
            .app-section h2 {
                font-size: 1.6em;
                margin-bottom: 20px;
            }
            input[type="text"], input[type="number"], textarea, select, input[type="email"] {
                width: 95%;
                max-width: none;
            }
            button {
                padding: 12px 20px;
                font-size: 15px;
            }
            .instruction-message {
                padding: 10px;
                font-size: 0.95em;
            }
            #instructionContainer .instruction-message {
                min-width: unset;
                max-width: 100%;
            }
            #filters {
                flex-direction: column;
                align-items: stretch;
                padding: 15px;
                gap: 15px;
            }
            .items-carousel-container {
                padding: 0 30px; /* Reduce padding for smaller buttons */
            }
            .carousel-nav-button {
                width: 40px;
                height: 40px;
                font-size: 1.2em;
            }
            .item-card {
                width: 95%;
                min-height: 400px;
                padding: 15px; /* Adjust card padding for mobile */
            }
            .front {
                flex-direction: column; /* Stack image and info vertically on mobile */
                align-items: center;
                gap: 15px;
                padding: 20px;
            }
            .item-image-container {
                width: 180px;
                height: 180px;
                margin: 0 auto; /* Center image */
            }
            .item-info {
                text-align: center;
                padding-right: 0;
                min-width: unset;
                width: 100%;
                padding-top: 0; /* Remove top padding for mobile stacking */
            }
            .item-info h3 {
                font-size: 1.3em;
                margin-bottom: 5px;
            }
            .item-info p, .item-info .final-price-display {
                font-size: 0.9em;
            }
            .quantity-control {
                justify-content: center; /* Center quantity controls on mobile */
                margin-top: 10px;
            }
            .item-card-subtotal {
                font-size: 1.1em;
                text-align: center; /* Center subtotal */
            }
            .card-action-buttons {
                flex-direction: row; /* Keep in row for space */
                justify-content: center;
                align-items: center;
                flex-wrap: wrap;
                margin-top: 15px;
                gap: 10px;
            }
            .card-action-buttons button {
                padding: 8px 15px;
                font-size: 0.9em;
                min-width: unset;
                flex-grow: 1; /* Allow growing */
            }
            .feedback-input-area {
                padding: 15px;
            }
            .feedback-input {
                max-width: 100%;
                min-height: 80px;
                padding: 10px;
            }
            .star-rating label {
                font-size: 2.2em;
                margin: 0 2px;
            }
            .past-feedbacks-section {
                max-height: 180px;
                padding: 15px;
            }
            #orderSummary ul li {
                padding: 10px 15px;
                font-size: 1em;
            }
            #orderTotalDisplay {
                font-size: 1.8em;
            }
            .checkout-buttons {
                gap: 10px;
            }
            .modal-content {
                padding: 20px;
            }
            #receiptContent h3 {
                font-size: 1.3em;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Welcome to Our Food Ordering App</h1>
    </header>

    <main>
        <!-- Initial Customer Name and Contact Entry Section -->
        <div id="customerNameEntry" class="app-section">
            <h2>Enter Your Details to Start Ordering</h2>
            <input type="text" id="initialCustomerNameInput" placeholder="Your Name" required>
            <input type="text" id="customerContactInput" placeholder="Your Email or Contact Number" required>
            <p id="nameEntryError" class="error-message">Please enter your name and contact information to proceed.</p>
            <button id="startOrderingButton">Start Ordering</button>
        </div>

        <!-- Main Content Section (Food Items Display) -->
        <div id="mainContent" class="app-section" style="display: none;">
            <p id="mainErrorMessage" class="error-message"></p>
            
            <div id="instructionContainer">
                <p id="instructionMessage" class="instruction-message"></p>
                <p id="exchangePolicyMessage" class="instruction-message"></p>
            </div>

            <!-- Filters for Food Items -->
            <div id="filters">
                <label for="searchInput">Search:</label>
                <input type="text" id="searchInput" placeholder="Search by name or tag">

                <label for="categorySelect">Category:</label>
                <select id="categorySelect">
                    <option value="">All Categories</option>
                </select>

                <!-- NEW: Main Category Filter -->
                <label for="mainCategorySelect">Main Category:</label>
                <select id="mainCategorySelect">
                    <option value="">All Main Categories</option>
                </select>

                <label for="ratingFilterSelect">Min. Rating:</label>
                <select id="ratingFilterSelect">
                    <option value="0">Any Rating</option>
                    <option value="1">★ & up</option>
                    <option value="2">★★ & up</option>
                    <option value="3">★★★ & up</option>
                    <option value="4">★★★★ & up</option>
                    <option value="5">★★★★★</option>
                </select>
                <button id="viewSelectedItemsButton">View Selected Items</button>
            </div>

            <!-- Items Carousel Container -->
            <div class="items-carousel-container">
                <button class="carousel-nav-button prev" id="prevItemButton"><i class="fas fa-chevron-left"></i></button>
                <div id="itemsList">
                    <!-- Food item cards will be dynamically rendered here -->
                </div>
                <button class="carousel-nav-button next" id="nextItemButton"><i class="fas fa-chevron-right"></i></button>
            </div>
        </div>

        <!-- Order Summary Section -->
        <div id="orderSummary" class="app-section" style="display: none;">
            <h2>Your Order Summary</h2>
            <ul id="orderItemsList">
                <!-- Selected order items will be listed here -->
            </ul>
            <p id="orderTotalDisplay"></p>
            <div class="checkout-buttons">
                <button id="proceedToCheckoutButton">Proceed to Checkout</button>
                <button onclick="document.getElementById('orderSummary').style.display = 'none'; document.getElementById('mainContent').style.display = 'block';">Continue Shopping</button>
            </div>
        </div>

        <!-- Checkout Form Section -->
        <div id="checkoutForm" class="app-section" style="display: none;">
            <h2>Confirm Your Order</h2>
            <p>Customer: <span id="checkoutCustomerNameDisplay"></span></p>
            <p>Contact: <span id="checkoutCustomerContactDisplay"></span></p>
            <p>You are about to place an order. Please confirm.</p>

            <div class="payment-method-section">
                <label for="paymentMethodSelect">Choose Payment Method:</label>
                <select id="paymentMethodSelect">
                    <option value="cash">Cash on Delivery</option>
                    <!--<option value="online">Online Payment (UPI)</option>-->
                    <option value="scanqr">Scan QR</option> <!-- New option added here -->
                </select>

                <div id="upiDetailsSection" style="display: none;">
                    <p style="font-weight: bold; color: #0056b3;">Pay via UPI</p>
                    <p>Shop UPI ID: <span id="shopUpiIdDisplay">Loading...</span></p>
                    <button id="copyUpiIdButton" class="small-button" style="background-color: #28a745;">Copy UPI ID</button>
                    <p>Transaction ID: <span id="transactionIdDisplay">N/A</span></p>
                    <button id="confirmPaymentButton" class="small-button" style="background-color: #007bff;">Confirm Payment</button>
                    <div style="display: flex; justify-content: center; gap: 15px; margin-top: 20px;">
                        <button id="payWithPhonePe" class="upi-app-button">Pay with PhonePe</button>
                        <button id="payWithGPay" class="upi-app-button">Pay with GPay</button>
                        <button id="payWithPaytm" class="upi-app-button">Pay with Paytm</button> <!-- Paytm button added here -->
                    </div>
                    <p style="font-size: 0.9em; color: #555; margin-top: 15px;">After successful payment, click "Place Order".</p>
                </div>

                <!-- New QR Code Payment Section -->
                <div id="qrDetailsSection" style="display: none;">
                    <p style="font-weight: bold; color: #0056b3;">Scan QR to Pay</p>
                    <div id="qrCodeImageContainer" style="margin-top: 10px; text-align: center;">
                        <img id="qrCodeImage" src="https://placehold.co/200x200/CCCCCC/000000?text=QR+Code" alt="QR Code" style="width: 200px; height: 200px; border: 1px solid #ddd; border-radius: 8px;">
                        <p style="font-size: 0.85em; color: #888; margin-top: 5px;">Scan this QR code with your UPI app.</p>
                    </div>
                    <p style="margin-top: 15px;">Enter Transaction ID:</p>
                    <input type="text" id="qrTransactionIdInput" placeholder="Enter Transaction ID" style="width: 100%; max-width: 300px;">
                    <button id="confirmQrPaymentButton" class="small-button" style="background-color: #007bff; margin-top: 10px;">Confirm QR Payment</button>
                    <p style="font-size: 0.9em; color: #555; margin-top: 15px;">After successful payment and entering ID, click "Place Order".</p>
                </div>
                <!-- End New QR Code Payment Section -->
            </div>

            <div class="checkout-buttons">
                <button id="placeFinalOrderButton">Place Order</button>
                <button onclick="document.getElementById('checkoutForm').style.display = 'none'; document.getElementById('orderSummary').style.display = 'flex'; displaySelectedItems();">Back to Summary</button>
            </div>
        </div>

        <!-- Final Order Details Section -->
        <div id="finalOrderDetails" class="app-section" style="display: none;">
            <h2>Order Placed Successfully!</h2>
            <p>Thank you, <span id="finalCustomerNameDisplay"></span>!</p>
            <p>We will contact you at: <span id="finalCustomerContactDisplay"></span></p>
            <p id="finalOrderIdDisplay"></p>
            <p id="finalEstimatedDeliveryDisplay">Estimated Delivery: N/A</p> <!-- New: Estimated Delivery Time -->
            <h3>Items in Your Order:</h3>
            <ul id="finalOrderItemsListDiv">
                <!-- Final ordered items will be listed here -->
            </ul>
            <p id="finalOrderTotalDisplay"></p>
            <div class="checkout-buttons">
                <button id="viewReceiptButton">View Receipt</button>
                <button onclick="window.location.reload();">Start New Order</button>
            </div>
        </div>
    </main>
    <div id="feedbackModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="feedbackModalClose">&times;</span>
            <h2 id="feedbackModalTitle"></h2>
            <ul id="feedbackModalList" class="feedback-list">
                <!-- Feedback items will be listed here -->
            </ul>
        </div>
    </div>
    <div id="receiptModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="receiptModalClose">&times;</span>
            <h2>Order Receipt</h2>
            <div id="receiptContent">
                <!-- Receipt details will be generated here -->
            </div>
            <button id="downloadReceiptButton" class="small-button" style="background-color: #007bff; margin-top: 20px;">Download Receipt</button>
        </div>
    </div>

    <!-- Desktop Mode Prompt Modal -->
    <div id="mobilePromptModal" class="modal">
        <div class="modal-content">
            <h2>Optimal Experience</h2>
            <p>For a better experience, we recommend switching to desktop mode. This might improve navigation and layout on smaller screens.</p>
            <div class="modal-buttons">
                <button id="switchToDesktopButton">Switch to Desktop Mode</button>
                <!-- Removed "No Thanks" button -->
            </div>
        </div>
    </div>

    <script>
        // Backend URL where your server is running
        //const BACKEND_URL = "";
        const BACKEND_URL = 'http://localhost:8084';
        // --- DOM Element References ---
        const customerNameEntryDiv = document.getElementById('customerNameEntry');
        const initialCustomerNameInput = document.getElementById('initialCustomerNameInput');
        const customerContactInput = document.getElementById('customerContactInput');
        const nameEntryErrorDiv = document.getElementById('nameEntryError');
        const startOrderingButton = document.getElementById('startOrderingButton');

        const mainContentDiv = document.getElementById('mainContent');
        const mainErrorMessageDiv = document.getElementById('mainErrorMessage');
        const instructionContainer = document.getElementById('instructionContainer');
        const instructionMessageDiv = document.getElementById('instructionMessage');
        const exchangePolicyMessage = document.getElementById('exchangePolicyMessage');
        const searchInput = document.getElementById('searchInput');
        const categorySelect = document.getElementById('categorySelect');
        const mainCategorySelect = document.getElementById('mainCategorySelect'); // NEW DOM reference
        const ratingFilterSelect = document.getElementById('ratingFilterSelect');
        const itemsListDiv = document.getElementById('itemsList');
        const viewSelectedItemsButton = document.getElementById('viewSelectedItemsButton');

        const orderSummaryDiv = document.getElementById('orderSummary');
        const orderItemsList = document.getElementById('orderItemsList');
        const orderTotalDisplay = document.getElementById('orderTotalDisplay');
        const proceedToCheckoutButton = document.getElementById('proceedToCheckoutButton');

        const checkoutFormDiv = document.getElementById('checkoutForm');
        const checkoutCustomerNameDisplay = document.getElementById('checkoutCustomerNameDisplay');
        const checkoutCustomerContactDisplay = document.getElementById('checkoutCustomerContactDisplay');
        const placeFinalOrderButton = document.getElementById('placeFinalOrderButton');

        const finalOrderDetailsDiv = document.getElementById('finalOrderDetails');
        const finalOrderIdDisplay = document.getElementById('finalOrderIdDisplay');
        const finalEstimatedDeliveryDisplay = document.getElementById('finalEstimatedDeliveryDisplay'); // New reference
        const finalOrderItemsListDiv = document.getElementById('finalOrderItemsListDiv');
        const finalOrderTotalDisplay = document.getElementById('finalOrderTotalDisplay');
        const finalCustomerNameDisplay = document.getElementById('finalCustomerNameDisplay');
        const finalCustomerContactDisplay = document.getElementById('finalCustomerContactDisplay');
        const viewReceiptButton = document.getElementById('viewReceiptButton');

        const paymentMethodSelect = document.getElementById('paymentMethodSelect');
        const upiDetailsSection = document.getElementById('upiDetailsSection');
        const shopUpiIdDisplay = document.getElementById('shopUpiIdDisplay');
        const copyUpiIdButton = document.getElementById('copyUpiIdButton');
        const payWithPhonePeButton = document.getElementById('payWithPhonePe');
        const payWithGPayButton = document.getElementById('payWithGPay');
        const payWithPaytmButton = document.getElementById('payWithPaytm'); // New Paytm button reference
        const transactionIdDisplay = document.getElementById('transactionIdDisplay');
        const confirmPaymentButton = document.getElementById('confirmPaymentButton');

        // New QR Payment DOM Elements
        const qrDetailsSection = document.getElementById('qrDetailsSection');
        const qrCodeImage = document.getElementById('qrCodeImage');
        const qrTransactionIdInput = document.getElementById('qrTransactionIdInput');
        const confirmQrPaymentButton = document.getElementById('confirmQrPaymentButton');


        const feedbackModal = document.getElementById('feedbackModal');
        const feedbackModalClose = document.getElementById('feedbackModalClose');
        const feedbackModalTitle = document.getElementById('feedbackModalTitle');
        const feedbackModalList = document.getElementById('feedbackModalList');

        const receiptModal = document.getElementById('receiptModal');
        const receiptModalClose = document.getElementById('receiptModalClose');
        const receiptContent = document.getElementById('receiptContent');
        const downloadReceiptButton = document.getElementById('downloadReceiptButton');

        const prevItemButton = document.getElementById('prevItemButton');
        const nextItemButton = document.getElementById('nextItemButton');

        const mobilePromptModal = document.getElementById('mobilePromptModal');
        const switchToDesktopButton = document.getElementById('switchToDesktopButton');
        // const noThanksButton = document.getElementById('noThanksButton'); // Removed reference

        // --- Global State Variables ---
        let userId = ''; // This will be populated from the URL
        let customerName = '';
        let customerContact = '';
        let storeName = ''; // This will be populated from the URL
        let allItems = []; // Stores all food items fetched from the backend
        let selectedItems = {}; // Stores items currently selected by the customer
        let shopUpiId = ''; // UPI ID fetched for online payments
        let shopQrImageData = null; // To store the base64 QR image
        let finalOrderData = null; // Stores details of the last placed order
        let isPaymentConfirmed = false; // New state for UPI payment confirmation

        // Shop owner's subscription status, affecting item prices
        let hasShopSubscription = false;
        let shopSubscriptionExpiryDate = null;

        // Carousel state
        let currentCarouselIndex = 0;
        let touchStartX = 0;

        // Unit conversion factors for price calculations
        const unitConversionFactors = {
            'kg': 1,
            'litre': 1,
            'gm': 0.001, // 1 gram = 0.001 kg
            'ml': 0.001 // 1 ml = 0.001 litre
        };

        // --- Utility Functions ---

        /**
         * Calculates the price increment based on the original price for subscribed shops.
         * This mirrors the backend logic for subscription pricing.
         * @param {number} originalPrice - The original price of the item.
         * @returns {number} The calculated price increment.
         */
        function calculateSubscriptionPriceIncrementFrontend(originalPrice) {
            let increment = 0;
            if (originalPrice >= 0 && originalPrice <= 30) {
                increment = 3;
            } else if (originalPrice > 30 && originalPrice <= 60) {
                increment = 5;
            } else if (originalPrice > 60 && originalPrice <= 90) {
                increment = 7;
            } else if (originalPrice > 90 && originalPrice <= 120) {
                increment = 9;
            } else if (originalPrice > 120) {
                increment = 9;
                const diff = originalPrice - 120;
                const intervals = Math.floor(diff / 30);
                increment += intervals * 2;
            }
            return increment;
        }

        /**
         * Calculates a price increment based on defined price ranges.
         * This is the new function implementing the user's requested logic.
         * @param {number} originalPrice - The original price of the item.
         * @returns {number} The calculated price increment based on ranges.
         */
        function calculatePriceIncrementBasedOnRange(originalPrice) {
            let initialIncrement = 0;

    // Step 1: Determine the base increment based on the price range
    if (originalPrice === 0) {
        initialIncrement = 0;
    } else if (originalPrice >= 1 && originalPrice <= 5) {
        initialIncrement = 1;
    } else if (originalPrice >= 6 && originalPrice <= 10) {
        initialIncrement = 2;
    } else if (originalPrice >= 11 && originalPrice <= 30) {
        initialIncrement = 3;
    } else if (originalPrice >= 31 && originalPrice <= 60) {
        initialIncrement = 5;
    } else if (originalPrice >= 61 && originalPrice <= 90) {
        initialIncrement = 7;
    } else if (originalPrice >= 91) {
        // For prices 91 and above, the increment increases by 2 for every 30-unit increase
        initialIncrement = 7 + Math.ceil((originalPrice - 90) / 30) * 2;
    }

    // Step 2: Calculate the price after the first increment to use for the second increment calculation
    let newPrice = originalPrice + initialIncrement;

    // Step 3: Calculate the additional 3% increment
    let moreIncrement = newPrice * 0.03;

    // Step 4: Sum both increments to get the total increment
    let increment = initialIncrement + moreIncrement;

    return increment;
        }

        /**
         * Extracts userId and storeName from the URL path.
         */
        function getUrlParameters() {
            const pathSegments = window.location.pathname.split('/');
            // Example URL: /customer/order/{userId}/{storeName}
            // pathSegments will look like ["", "customer", "order", "{userId}", "{storeName}"]
            if (pathSegments.length >= 5 && pathSegments[1] === 'customer' && pathSegments[2] === 'order') {
                userId = pathSegments[3];
                storeName = decodeURIComponent(pathSegments[4]);
                console.log("DEBUG: Inside getUrlParameters - Extracted userId:", userId);
                console.log("DEBUG: Inside getUrlParameters - Extracted storeName:", storeName);
            } else {
                console.warn("DEBUG: URL path segments are not as expected or missing. Length:", pathSegments.length, "Path:", window.location.pathname);
                // Fallback for direct access to index.html for debugging purposes
                // If you are accessing directly like http://localhost:8084/index.html
                // you might want to hardcode a userId for testing until you use the full path
                // userId = 'YOUR_TEST_USER_ID_HERE'; // Uncomment for direct index.html access testing
            }
        }
        // Call getUrlParameters immediately when the script loads to populate userId and storeName
        getUrlParameters();
        console.log("DEBUG: After getUrlParameters call - Global userId:", userId);
        console.log("DEBUG: After getUrlParameters call - Global storeName:", storeName);


        /**
         * Renders star icons based on a given rating.
         * @param {number} rating - The numerical rating.
         * @returns {string} HTML string of star icons.
         */
        function renderStars(rating) {
            const fullStars = Math.floor(rating);
            const halfStar = rating % 1 >= 0.5;
            let starsHtml = '';
            for (let i = 0; i < fullStars; i++) {
                starsHtml += '★';
            }
            if (halfStar) {
                starsHtml += '½';
            }
            for (let i = 0; i < (5 - fullStars - (halfStar ? 1 : 0)); i++) {
                starsHtml += '☆';
            }
            return starsHtml;
        }

        /**
         * Parses "Buy N Get M Free" discount text into quantities and units.
         * @param {string} text - The discount text.
         * @returns {object|null} An object with buyQuantity, getQuantity, and unit, or null if no match.
         */
        function parseBuyNGetMFree(text) {
            const match = text.match(/buy (\d+) get (\d+)(?: (\w+))? free/i);
            if (match) {
                return {
                    buyQuantity: parseInt(match[1]),
                    getQuantity: parseInt(match[2]),
                    unit: match[3] || null
                };
            }
            return null;
        }

        /**
         * Calculates the subtotal for a single item, considering discounts and units.
         * @param {object} itemData - The original item data from allItems.
         * @param {number} quantity - The selected quantity for the item.
         * @param {string} selectedUnit - The selected unit (e.g., 'kg', 'gm').
         * @returns {number} The calculated subtotal for the item (rounded to nearest integer).
         */
        function calculateItemSubtotal(itemData, quantity, selectedUnit) {
            const originalItem = allItems.find(i => i._id === itemData._id);

            if (!originalItem) {
                console.error(`Original item data not found for itemId: ${itemData._id}`);
                return 0;
            }

            let calculatedPricePerUnit = typeof originalItem.price === 'number' ? originalItem.price : 0;

            // Apply the new price increment based on range
            const rangeIncrement = calculatePriceIncrementBasedOnRange(calculatedPricePerUnit);
            if (rangeIncrement > 0) {
                calculatedPricePerUnit += rangeIncrement;
            }

            // Apply subscription increment if shop is subscribed and not expired
            if (hasShopSubscription && shopSubscriptionExpiryDate && new Date() < shopSubscriptionExpiryDate) {
                const subscriptionIncrement = calculateSubscriptionPriceIncrementFrontend(calculatedPricePerUnit);
                if (subscriptionIncrement > 0) {
                    calculatedPricePerUnit += subscriptionIncrement;
                }
            }
            
            const netPricePerUnit = calculatedPricePerUnit;

            let finalPricePerUnit = netPricePerUnit;
            // Apply percentage or flat discount
            if (originalItem.discountType === '%' && typeof originalItem.discountValue === 'number' && originalItem.discountValue !== null) {
                finalPricePerUnit = netPricePerUnit * (1 - originalItem.discountValue / 100);
            } else if (originalItem.discountType === 'flat' && typeof originalItem.discountValue === 'number' && originalItem.discountValue !== null) {
                finalPricePerUnit = netPricePerUnit - originalItem.discountValue;
                if (finalPricePerUnit < 0) finalPricePerUnit = 0; // Ensure price doesn't go below zero
            }
            
            let calculatedQuantity = quantity;
            const basePriceUnit = originalItem.unit || originalItem.weightUnit;

            // Convert quantity if selected unit is different from base unit
            if (selectedUnit && basePriceUnit && selectedUnit.toLowerCase() !== basePriceUnit.toLowerCase()) {
                const conversionFactor = unitConversionFactors[selectedUnit.toLowerCase()];
                if (conversionFactor !== undefined) {
                    calculatedQuantity = quantity * conversionFactor;
                } else {
                    console.warn(`No conversion factor found for unit: ${selectedUnit}. Assuming quantity is in base unit.`);
                }
            }

            // Apply "Buy N Get M Free" discount
            if (originalItem.discountType === 'other' && originalItem.otherDiscountText) {
                const buyNGetMFreeDetails = parseBuyNGetMFree(originalItem.otherDiscountText);
                if (buyNGetMFreeDetails) {
                    const { buyQuantity, getQuantity } = buyNGetMFreeDetails;
                    if (buyQuantity > 0) {
                        const freeUnits = Math.floor(calculatedQuantity / buyQuantity) * getQuantity;
                        calculatedQuantity = calculatedQuantity - freeUnits;
                        if (calculatedQuantity < 0) calculatedQuantity = 0;
                    }
                }
            }
            
            // Return price rounded to the nearest integer
            return Math.round(calculatedQuantity * finalPricePerUnit);
        }
        async function initialLoadItems() {
            // userId and storeName should already be populated by getUrlParameters()
            console.log("DEBUG: initialLoadItems called. Current userId:", userId);

            if (!userId) {
                mainErrorMessageDiv.textContent = 'User ID not found in URL. Please use a valid link in the format /customer/order/{userId}/{storeName}.';
                mainErrorMessageDiv.style.display = 'block';
                return;
            }

            try {
                // Fetch shop owner details (for subscription status and UPI ID)
                const userDetailsResponse = await fetch(`${BACKEND_URL}/userDetails?userId=${userId}`);
                if (!userDetailsResponse.ok) {
                    const errorText = await userDetailsResponse.text();
                    throw new Error(`HTTP error fetching user details! status: ${userDetailsResponse.status}, body: ${errorText}`);
                }
                const userData = await userDetailsResponse.json();
                // FIX: Changed from userData.hasSubscribed to userData.isSubscribed
                hasShopSubscription = userData.isSubscribed || false; 
                shopSubscriptionExpiryDate = userData.subscriptionExpiryDate ? new Date(userData.subscriptionExpiryDate) : null;
                console.log(`Frontend: Shop owner subscription status: isSubscribed=${hasShopSubscription}, subscriptionExpiryDate=${shopSubscriptionExpiryDate}`);

                // Fetch food items
                const response = await fetch(`${BACKEND_URL}/foodItems?userId=${userId}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);
                }
                allItems = await response.json();
                console.log('Fetched food items:', allItems);

                populateCategories(allItems);
                populateMainCategories(allItems); // NEW: Populate main categories
                filterItems(); // Render items after fetching
                mainErrorMessageDiv.style.display = 'none'; // Hide any previous error
                updateCarouselNavButtons(); // Update carousel buttons based on initial items
            } catch (error) {
                console.error('Error fetching data:', error);
                mainErrorMessageDiv.textContent = 'Failed to load data. ' + error.message;
                mainErrorMessageDiv.style.display = 'block';
            }
        }

        /**
         * Fetches shop instructions (welcome message, exchange policy) from the backend.
         */
        async function fetchShopInstructions() {
            try {
                const response = await fetch(`${BACKEND_URL}/instructions?userId=${userId}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, body: ${response.statusText}`);
                }
                const instructionsData = await response.json();
                console.log('Fetched shop instructions:', instructionsData);

                // Set a default welcome message
                instructionMessageDiv.textContent = `
                    Welcome to the food ordering app! Here's how to place your order:
                    
                        Browse Items:Scroll through the food items using the navigation arrows or by swiping.
                        Select & Customize: Check the box on an item to add it to your order. Adjust the quantity and unit (if applicable)
                        Provide Feedback: Click "Show Feedback" on an item card to see past reviews or "Give Feedback" to leave your own rating and comment.
                        Review Order: When you're ready, click "View Selected Items" to see your order summary.
                        Checkout: On the summary page, click "Proceed to Checkout" to finalize your order and choose a payment method.
                    
                    Enjoy your meal!
                `;
                instructionContainer.style.display = 'flex'; // Show instructions container

                let exchangePolicyText = 'No specific exchange policy available.';
                if (Array.isArray(instructionsData) && instructionsData.length > 0) {
                    const exchangePolicy = instructionsData.find(inst => inst.type === 'exchangePolicy');
                    if (exchangePolicy) {
                        exchangePolicyText = exchangePolicy.instructionText;
                    } else {
                        const generalPolicy = instructionsData.find(inst => inst.type === 'generalPolicy');
                        if (generalPolicy) {
                            exchangePolicyText = generalPolicy.instructionText;
                        } else if (instructionsData[0] && instructionsData[0].instructionText) {
                            exchangePolicyText = instructionsData[0].instructionText;
                        }
                    }
                } else if (typeof instructionsData === 'string' && instructionsData.includes('no exchange')) {
                    exchangePolicyText = instructionsData;
                }

                exchangePolicyMessage.textContent = `Shop Policy: ${exchangePolicyText}`;
                exchangePolicyMessage.style.display = 'block';
            } catch (error) {
                console.error('Error fetching shop instructions:', error);
                exchangePolicyMessage.textContent = 'Failed to load shop policy.';
                exchangePolicyMessage.style.display = 'block';
            }
        }

        /**
         * Populates the category filter dropdown with unique categories from fetched items.
         * @param {Array<object>} items - The list of food items.
         */
        function populateCategories(items) {
            const categories = new Set();
            items.forEach(item => {
                if (item.category) {
                    categories.add(item.category);
                }
            });
            categorySelect.innerHTML = '<option value="">All Categories</option>'; // Always include 'All' option
            categories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categorySelect.appendChild(option);
            });
        }

        /**
         * NEW: Populates the main category filter dropdown with unique main categories from fetched items.
         * @param {Array<object>} items - The list of food items.
         */
        function populateMainCategories(items) {
            const mainCategories = new Set();
            items.forEach(item => {
                if (item.mainCategory) {
                    mainCategories.add(item.mainCategory);
                }
            });
            mainCategorySelect.innerHTML = '<option value="">All Main Categories</option>'; // Always include 'All' option
            mainCategories.forEach(mainCategory => {
                const option = document.createElement('option');
                option.value = mainCategory;
                option.textContent = mainCategory;
                mainCategorySelect.appendChild(option);
            });
        }

        /**
         * Filters the `allItems` based on current search, category, main category, and rating filters,
         * then re-renders the displayed items.
         */
        function filterItems() {
            const searchTerm = searchInput.value.toLowerCase();
            const selectedCategory = categorySelect.value;
            const selectedMainCategory = mainCategorySelect.value; // NEW: Get selected main category
            const minRating = parseFloat(ratingFilterSelect.value);

            const filtered = allItems.filter(item => {
                const matchesSearch = item.name.toLowerCase().includes(searchTerm) ||
                                        (item.description && item.description.toLowerCase().includes(searchTerm)) ||
                                        (item.tags && item.tags.some(tag => tag.toLowerCase().includes(searchTerm)));
                const matchesCategory = selectedCategory === '' || item.category === selectedCategory;
                const matchesMainCategory = selectedMainCategory === '' || item.mainCategory === selectedMainCategory; // NEW: Filter by main category
                const matchesRating = !item.averageRating || item.averageRating >= minRating; // If no rating, always show

                return matchesSearch && matchesCategory && matchesMainCategory && matchesRating; // NEW: Include main category in filter
            });
            renderItems(filtered); // Render the filtered subset
            currentCarouselIndex = 0; // Reset carousel position
            scrollToItem(currentCarouselIndex); // Scroll to the first item
            updateCarouselNavButtons(); // Update carousel button states
        }
        function renderItems(items) {
            itemsListDiv.innerHTML = ''; // Clear existing items
            if (items && items.length > 0) {
                items.forEach(item => {
                    renderSingleItem(itemsListDiv, item); // Render each item card
                });
            } else {
                itemsListDiv.innerHTML = '<p style="text-align: center; width: 100%; color: #6c757d; font-size: 1.1em;">No items found matching your criteria.</p>';
            }
            // Attach delegated listeners to the parent after all items are rendered
            // This is crucial to ensure event listeners are active for dynamically added/replaced elements.
            attachDelegatedEventListeners();
        }
        function renderSingleItem(containerElement, item) {
            const isItemSelected = selectedItems[item._id];
            // Get current state from selectedItems if item is selected, otherwise default values
            const currentSelectedState = isItemSelected ? selectedItems[item._id] : {
                quantity: 1, // Default for new items
                unit: item.unit || item.weightUnit || '', // Default unit
                feedback: '',
                liked: false,
                rating: 0,
                isFeedbackInputActive: false, // Default to showing past reviews
                isFeedbackFlipped: false, // Default for card flip
                isDescriptionFlipped: false // Default for card flip
            };

            const itemCard = document.createElement('div');
            itemCard.classList.add('item-card');
            if (isItemSelected) {
                itemCard.classList.add('selected'); // Add 'selected' class if checked
            }
            // Apply flipped classes if item was previously flipped
            if (currentSelectedState.isFeedbackFlipped) {
                itemCard.classList.add('flipped-feedback');
            } else if (currentSelectedState.isDescriptionFlipped) {
                itemCard.classList.add('flipped-description');
            }
            // Determine if unit dropdown should be shown
            const showUnitDropdown = item.unit || item.weightUnit;
            let unitDropdownHtml = '';
            if (showUnitDropdown) {
                unitDropdownHtml = `
                    <label for="unit-${item._id}">Unit:</label>
                    <select id="unit-${item._id}" class="unit-select" ${isItemSelected ? '' : 'disabled'}>
                        <option value="kg" ${currentSelectedState.unit === 'kg' ? 'selected' : ''}>kg</option>
                        <option value="litre" ${currentSelectedState.unit === 'litre' ? 'selected' : ''}>Litre</option>
                        <option value="gm" ${currentSelectedState.unit === 'gm' ? 'selected' : ''}>gm</option>
                        <option value="ml" ${currentSelectedState.unit === 'ml' ? 'selected' : ''}>ml</option>
                    </select>
                `;
            }

            // Calculate prices with custom increment and then subscription increment, then round to nearest integer
            let priceBeforeDiscountAndRounding = typeof item.price === 'number' ? item.price : 0;
            
            // Apply the new price increment based on range
            const rangeIncrement = calculatePriceIncrementBasedOnRange(priceBeforeDiscountAndRounding);
            if (rangeIncrement > 0) {
                priceBeforeDiscountAndRounding += rangeIncrement;
            }

            let subscriptionApplied = false; // Flag to track if subscription increment was applied
            if (hasShopSubscription && shopSubscriptionExpiryDate && new Date() < shopSubscriptionExpiryDate) {
                const subscriptionIncrement = calculateSubscriptionPriceIncrementFrontend(priceBeforeDiscountAndRounding);
                if (subscriptionIncrement > 0) { // Only consider it "incremented" if there's an actual increment
                    priceBeforeDiscountAndRounding += subscriptionIncrement;
                    subscriptionApplied = true; // Set the flag to true
                }
            }
            const netPrice = Math.round(priceBeforeDiscountAndRounding); // Round here for display
            
            // Calculate final discounted price and round
            let calculatedDiscountedPrice = netPrice; // Start from the rounded netPrice
            if (item.discountType === '%' && typeof item.discountValue === 'number' && item.discountValue !== null) {
                calculatedDiscountedPrice = netPrice * (1 - item.discountValue / 100);
            } else if (item.discountType === 'flat' && typeof item.discountValue === 'number' && item.discountValue !== null) {
                calculatedDiscountedPrice = netPrice - item.discountValue;
                if (calculatedDiscountedPrice < 0) calculatedDiscountedPrice = 0; // Ensure price doesn't go below zero
            }
            const displayedDiscountedPrice = Math.round(calculatedDiscountedPrice); // Round again for final display

            // Determine how price should be displayed
            let priceLabel = 'Price:';
            let priceDisplayHtml = '';
            if (netPrice !== displayedDiscountedPrice) { // Compare rounded values
                priceDisplayHtml += `<span class="original-price">₹${netPrice}</span> <span class="discounted-price">₹${displayedDiscountedPrice}</span>`;
            } else {
                priceDisplayHtml += `₹${netPrice}`;
            }
            
            // Determine which discount badge to show
            let discountBadgeHtml = '';
            if (item.discountType === '%' && typeof item.discountValue === 'number' && item.discountValue !== null) {
                discountBadgeHtml = `<span class="discount-badge">${item.discountValue}% OFF</span>`;
            } else if (item.discountType === 'flat' && typeof item.discountValue === 'number' && item.discountValue !== null) {
                discountBadgeHtml = `<span class="discount-badge">₹${item.discountValue} OFF</span>`;
            } else if (item.otherDiscountText) {
                discountBadgeHtml = `<span class="tag-badge">${item.otherDiscountText}</span>`; // Changed to tag-badge for consistency
            }

            // Determine the image source based on imageData or imageUrl
            const imageSource = item.imageData 
                                    ? item.imageData 
                                    : (item.imageUrl || 'https://placehold.co/180x180/CCCCCC/000000?text=No+Image');

            // Calculate initial subtotal for display
            const initialSubtotal = calculateItemSubtotal(item, currentSelectedState.quantity, currentSelectedState.unit);

            itemCard.innerHTML = `
                <div class="front">
                    <input type="checkbox" id="item-${item._id}" value="${item._id}"
                        data-name="${item.name}" data-price="${item.price}"
                        ${isItemSelected ? 'checked' : ''}>
                    <div class="discount-top-right">
                        ${discountBadgeHtml}
                    </div>
                    <div class="item-image-container">
                        <img src="${imageSource}" alt="${item.name}" class="item-image" onerror="this.onerror=null;this.src='https://placehold.co/180x180/CCCCCC/000000?text=No+Image';">
                    </div>
                    <div class="item-info">
                        <h3>${item.name}</h3>
                        <p>Category: ${item.category || 'N/A'}</p>
                        <p>Main Category: ${item.mainCategory || 'N/A'}</p> <!-- Display Main Category -->
                        <p class="final-price-display">${priceLabel} ${priceDisplayHtml}</p>
                        <p class="average-rating">
                            Average Rating:
                            ${item.averageRating ? `<span style="color: gold;">${renderStars(item.averageRating)} (${item.averageRating.toFixed(1)})</span>` : 'Not yet rated'}
                        </p>
                        <div class="quantity-control">
                            <label for="quantity-${item._id}">Qty:</label>
                            <input type="number" id="quantity-${item._id}" class="quantity-input" value="${currentSelectedState.quantity}" min="1" ${isItemSelected ? '' : 'disabled'}>
                            ${unitDropdownHtml}
                        </div>
                        <p class="item-card-subtotal" id="item-subtotal-${item._id}">Item Total: ₹${initialSubtotal}</p>
                        <div class="item-tags-container" id="tags-${item._id}">
                            ${item.tags && item.tags.length > 0 ?
                                item.tags.map(tag => `<span class="tag-badge">${tag}</span>`).join('')
                                : ''}
                        </div>
                        <div class="card-action-buttons">
                            <button class="show-feedback-button">Show Feedback</button>
                            <button class="show-description-button">Show Description</button>
                        </div>
                    </div>
                </div>
                <div class="back-feedback ${currentSelectedState.isFeedbackInputActive ? 'show-input-face' : ''}">
                    <div class="past-feedback-display-area">
                        <h4>Past Customer Reviews:</h4>
                        <div class="past-feedbacks-container" style="width: 100%; max-height: 200px; overflow-y: auto;">
                            <div class="past-feedbacks-section">
                                ${item.feedbacks && item.feedbacks.length > 0 ?
                                item.feedbacks.map(fb => `
                                    <div class="past-feedback-item">
                                        <p><strong>${fb.customerName || 'Anonymous'}:</strong> ${fb.comment || 'No comment'}</p>
                                        <p>Rating: ${fb.rating ? renderStars(fb.rating) : 'N/A'}</p>
                                        <p>Liked: ${fb.liked ? 'Yes' : 'No'}</p>
                                        <p class="feedback-date">(${new Date(fb.createdAt).toLocaleDateString()})</p>
                                    </div>
                                `).join('')
                                : '<p style="text-align: center; color: #6c757d;">No past reviews yet.</p>'}
                            </div>
                        </div>
                        <div class="card-action-buttons">
                            <button class="give-feedback-button">Give Feedback</button>
                            <button class="back-to-details-button" data-flip-target="feedback">Back to Details</button>
                        </div>
                    </div>
                    <div class="feedback-input-area">
                        <h4>Provide Your Feedback for ${item.name}</h4>
                        <textarea class="feedback-input" placeholder="Your feedback..." rows="3" ${isItemSelected ? '' : 'disabled'}>${currentSelectedState.feedback || ''}</textarea>
                        <div class="feedback-buttons-row">
                            <button class="like-button ${currentSelectedState.liked ? 'liked' : ''}" data-item-id="${item._id}" ${isItemSelected ? '' : 'disabled'}>${currentSelectedState.liked ? 'Liked' : 'Like'}</button>
                            <button class="submit-feedback-button" data-item-id="${item._id}" ${isItemSelected ? '' : 'disabled'}>Submit Feedback</button>
                            <button class="back-from-feedback-input-button">Back</button>
                        </div>
                        <div class="star-rating">
                            <input type="radio" id="star5-${item._id}" name="rating-${item._id}" value="5" ${currentSelectedState.rating === 5 ? 'checked' : ''} ${isItemSelected ? '' : 'disabled'}><label for="star5-${item._id}">★</label>
                            <input type="radio" id="star4-${item._id}" name="rating-${item._id}" value="4" ${currentSelectedState.rating === 4 ? 'checked' : ''} ${isItemSelected ? '' : 'disabled'}><label for="star4-${item._id}">★</label>
                            <input type="radio" id="star3-${item._id}" name="rating-${item._id}" value="3" ${currentSelectedState.rating === 3 ? 'checked' : ''} ${isItemSelected ? '' : 'disabled'}><label for="star3-${item._id}">★</label>
                            <input type="radio" id="star2-${item._id}" name="rating-${item._id}" value="2" ${currentSelectedState.rating === 2 ? 'checked' : ''} ${isItemSelected ? '' : 'disabled'}><label for="star2-${item._id}">★</label>
                            <input type="radio" id="star1-${item._id}" name="rating-${item._id}" value="1" ${currentSelectedState.rating === 1 ? 'checked' : ''} ${isItemSelected ? '' : 'disabled'}><label for="star1-${item._id}">★</label>
                        </div>
                    </div>
                </div>
                <div class="back-description">
                    <h4>Description for ${item.name}</h4>
                    <div class="description-content">
                        <p>${item.description || 'No detailed description available for this item.'}</p>
                    </div>
                    <div class="card-action-buttons">
                            <button class="back-to-details-button" data-flip-target="description">Back to Details</button>
                    </div>
                </div>
            `;
            containerElement.appendChild(itemCard);
        }

        // --- Event Handlers for Item Card Interactions ---

        /**
         * Handles changes to item checkboxes, quantity inputs, and unit selects.
         * This uses event delegation for efficiency.
         * @param {Event} event - The DOM event.
         */
        function handleItemsListChange(event) {
            const target = event.target;
            const itemCard = target.closest('.item-card');
            if (!itemCard) return; // Ensure event originated from within an item card

            const itemId = itemCard.querySelector('input[type="checkbox"]').value;

            if (target.matches('.item-card input[type="checkbox"]')) {
                // If checkbox is clicked, update selectedItems state and enable/disable inputs
                const checkbox = target;
                const quantityInput = itemCard.querySelector(`#quantity-${itemId}`);
                const unitSelect = itemCard.querySelector(`#unit-${itemId}`);
                const feedbackInput = itemCard.querySelector(`.feedback-input`);
                const likeButton = itemCard.querySelector('.like-button');
                const submitFeedbackButton = itemCard.querySelector('.submit-feedback-button');
                const ratingInputs = itemCard.querySelectorAll(`.star-rating input[name="rating-${itemId}"]`);
                if (checkbox.checked) {
                    itemCard.classList.add('selected');
                    quantityInput.disabled = false;
                    if (unitSelect) unitSelect.disabled = false;
                    if (feedbackInput) feedbackInput.disabled = false;
                    if (likeButton) likeButton.disabled = false;
                    if (submitFeedbackButton) submitFeedbackButton.disabled = false;
                    ratingInputs.forEach(input => input.disabled = false);

                    const itemData = allItems.find(item => item._id === itemId);
                    if (itemData) {
                        // Initialize selected item with default values
                        selectedItems[itemId] = {
                            _id: itemId,
                            name: itemData.name,
                            price: itemData.price,
                            quantity: 1,
                            unit: itemData.unit || itemData.weightUnit || '',
                            feedback: '',
                            liked: false,
                            rating: 0,
                            imageUrl: itemData.imageUrl,
                            imageData: itemData.imageData, // Store imageData as well
                            discountType: itemData.discountType,
                            discountValue: itemData.discountValue,
                            otherDiscountText: itemData.otherDiscountText,
                            tags: itemData.tags || [],
                            // Estimated time is no longer stored per selected item as it's a shop-level property for delivery
                            isFeedbackInputActive: false, // Initial state for feedback sub-face
                            isFeedbackFlipped: false, // Initial state for card flip
                            isDescriptionFlipped: false // Initial state for card flip
                        };
                        quantityInput.value = 1; // Set default quantity
                        if (unitSelect) unitSelect.value = selectedItems[itemId].unit;
                    }
                } else {
                    // If checkbox is unchecked, remove from selectedItems and disable inputs
                    itemCard.classList.remove('selected');
                    quantityInput.disabled = true;
                    if (unitSelect) unitSelect.disabled = true;
                    if (feedbackInput) {
                        feedbackInput.disabled = true;
                        feedbackInput.value = ''; // Clear feedback
                    }
                    if (likeButton) {
                        likeButton.disabled = true;
                        likeButton.textContent = 'Like'; // Reset like button text
                        likeButton.classList.remove('liked'); // Remove liked class
                    }
                    if (submitFeedbackButton) submitFeedbackButton.disabled = true;
                    ratingInputs.forEach(input => input.disabled = true);
                    ratingInputs.forEach(input => input.checked = false); // Clear rating
                    
                    // Reset card flip states when item is deselected
                    itemCard.classList.remove('flipped-feedback', 'flipped-description');
                    delete selectedItems[itemId];
                }
                updateItemCardSubtotal(itemId); // Update subtotal display
                updateViewSelectedItemsButtonState(); // Update main "View Selected Items" button state
            } else if (target.matches('.quantity-input')) {
                const quantity = parseInt(target.value);
                if (selectedItems[itemId]) {
                    selectedItems[itemId].quantity = quantity;
                    updateItemCardSubtotal(itemId);
                }
            } else if (target.matches('.unit-select')) {
                const unit = target.value;
                if (selectedItems[itemId]) {
                    selectedItems[itemId].unit = unit;
                    updateItemCardSubtotal(itemId);
                }
            } else if (target.matches('.star-rating input[type="radio"]')) {
                // Update rating in selectedItems state
                if (selectedItems[itemId]) {
                    selectedItems[itemId].rating = parseInt(target.value);
                }
            }
        }

        /**
         * Handles click events within the items list, primarily for card flips and feedback actions.
         * Uses event delegation.
         * @param {Event} event - The DOM event.
         */
        function handleItemsListClick(event) {
            const target = event.target;
            const itemCard = target.closest('.item-card');
            if (!itemCard) return; // If click is not within an item card, do nothing

            const itemId = itemCard.querySelector('input[type="checkbox"]').value;
            const backFeedbackDiv = itemCard.querySelector('.back-feedback');

            if (target.classList.contains('show-feedback-button')) {
                // Flip to feedback side
                itemCard.classList.remove('flipped-description');
                itemCard.classList.add('flipped-feedback');
                if (selectedItems[itemId]) selectedItems[itemId].isFeedbackFlipped = true;
                if (selectedItems[itemId]) selectedItems[itemId].isDescriptionFlipped = false;

                // Ensure correct sub-face is displayed when flipping to feedback side
                if (backFeedbackDiv) {
                    // Based on stored state, show either feedback input or past reviews
                    if (selectedItems[itemId] && selectedItems[itemId].isFeedbackInputActive) {
                        backFeedbackDiv.classList.add('show-input-face');
                    } else {
                        backFeedbackDiv.classList.remove('show-input-face');
                    }
                }
            }
            else if (target.classList.contains('show-description-button')) {
                // Flip to description side
                itemCard.classList.remove('flipped-feedback');
                itemCard.classList.add('flipped-description');
                if (selectedItems[itemId]) selectedItems[itemId].isDescriptionFlipped = true;
                if (selectedItems[itemId]) selectedItems[itemId].isFeedbackFlipped = false;
            }
            else if (target.classList.contains('back-to-details-button')) {
                const flipTargetType = target.dataset.flipTarget;
                if (flipTargetType === 'feedback') {
                    // Flip back from feedback to front
                    itemCard.classList.remove('flipped-feedback');
                    if (selectedItems[itemId]) selectedItems[itemId].isFeedbackFlipped = false;
                    // Reset feedback input state when going back to front face
                    if (selectedItems[itemId]) {
                        selectedItems[itemId].isFeedbackInputActive = false;
                    }
                } else if (flipTargetType === 'description') {
                    // Flip back from description to front
                    itemCard.classList.remove('flipped-description');
                    if (selectedItems[itemId]) selectedItems[itemId].isDescriptionFlipped = false;
                }
            }
            else if (target.classList.contains('give-feedback-button')) {
                // Show feedback input form (internal flip)
                if (backFeedbackDiv) {
                    backFeedbackDiv.classList.add('show-input-face');
                    if (selectedItems[itemId]) {
                        selectedItems[itemId].isFeedbackInputActive = true;
                    }
                }
            } else if (target.classList.contains('back-from-feedback-input-button')) {
                // Go back to past feedbacks view (internal flip)
                if (backFeedbackDiv) {
                    backFeedbackDiv.classList.remove('show-input-face');
                    if (selectedItems[itemId]) {
                        selectedItems[itemId].isFeedbackInputActive = false;
                    }
                }
            } else if (target.classList.contains('like-button')) {
                // Toggle like state
                if (!target.disabled) { // Only toggle if not disabled
                    target.classList.toggle('liked');
                    target.textContent = target.classList.contains('liked') ? 'Liked' : 'Like';
                    if (selectedItems[itemId]) {
                        selectedItems[itemId].liked = target.classList.contains('liked');
                    }
                }
            } else if (target.classList.contains('submit-feedback-button')) {
                // Submit feedback for the item
                if (!target.disabled) { // Only submit if not disabled
                    submitFeedback(itemId);
                }
            } 
        }

        /**
         * Updates the subtotal displayed on an item card.
         * @param {string} itemId - The ID of the item.
         */
        function updateItemCardSubtotal(itemId) {
            const subtotalDisplay = document.getElementById(`item-subtotal-${itemId}`);
            const item = selectedItems[itemId];
            if (item && subtotalDisplay) {
                const itemData = allItems.find(i => i._id === itemId);
                if (itemData) {
                    const subtotal = calculateItemSubtotal(itemData, item.quantity, item.unit);
                    subtotalDisplay.textContent = `Item Total: ₹${subtotal}`;
                }
            } else if (subtotalDisplay) {
                // If item is deselected, reset subtotal to default for 1 unit of original item
                const itemData = allItems.find(i => i._id === itemId);
                if (itemData) {
                    const subtotal = calculateItemSubtotal(itemData, 1, itemData.unit || itemData.weightUnit);
                    subtotalDisplay.textContent = `Item Total: ₹${subtotal}`;
                }
            }
        }
        function updateViewSelectedItemsButtonState() {
            const hasSelectedItems = Object.keys(selectedItems).length > 0;
            viewSelectedItemsButton.disabled = !hasSelectedItems;
        }

        /**
         * Displays the selected items in the order summary section.
         */
        function displaySelectedItems() {
            orderItemsList.innerHTML = ''; // Clear previous list
            let total = 0;

            const selectedItemIds = Object.keys(selectedItems);
            if (selectedItemIds.length === 0) {
                orderItemsList.innerHTML = '<li style="text-align: center; color: #6c757d;">No items selected yet. Go back and select some!</li>';
                orderTotalDisplay.textContent = 'Total: ₹0';
                proceedToCheckoutButton.disabled = true;
                return;
            }

            proceedToCheckoutButton.disabled = false; // Enable checkout if items are present

            selectedItemIds.forEach(itemId => {
                const item = selectedItems[itemId];
                const originalItem = allItems.find(i => i._id === itemId);

                if (!originalItem) {
                    console.error(`Original item data not found for itemId: ${itemId}`);
                    return;
                }

                const itemTotal = calculateItemSubtotal(originalItem, item.quantity, item.unit);
                total += itemTotal; // Accumulate total order amount

                const basePriceUnit = originalItem.unit || originalItem.weightUnit;
                
                // Calculate prices with custom increment and then subscription increment, then round to nearest integer
                let priceBeforeDiscountAndRounding = typeof originalItem.price === 'number' ? originalItem.price : 0;
                
                // Apply the new price increment based on range
                const rangeIncrement = calculatePriceIncrementBasedOnRange(priceBeforeDiscountAndRounding);
                if (rangeIncrement > 0) {
                    priceBeforeDiscountAndRounding += rangeIncrement;
                }

                let subscriptionApplied = false;
                if (hasShopSubscription && shopSubscriptionExpiryDate && new Date() < shopSubscriptionExpiryDate) {
                    const subscriptionIncrement = calculateSubscriptionPriceIncrementFrontend(priceBeforeDiscountAndRounding);
                    if (subscriptionIncrement > 0) { // Only consider it "incremented" if there's an actual increment
                        priceBeforeDiscountAndRounding += subscriptionIncrement;
                        subscriptionApplied = true;
                    }
                }
                const netPrice = Math.round(priceBeforeDiscountAndRounding); // Round here for display
                
                let calculatedDiscountedPrice = netPrice; // Start from rounded netPrice
                if (originalItem.discountType === '%' && typeof originalItem.discountValue === 'number' && originalItem.discountValue !== null) {
                    calculatedDiscountedPrice = netPrice * (1 - originalItem.discountValue / 100);
                } else if (originalItem.discountType === 'flat' && typeof originalItem.discountValue === 'number' && originalItem.discountValue !== null) {
                    calculatedDiscountedPrice = netPrice - originalItem.discountValue;
                    if (calculatedDiscountedPrice < 0) calculatedDiscountedPrice = 0;
                }
                const displayedDiscountedPrice = Math.round(calculatedDiscountedPrice); // Round again for final display

                let priceDisplay = `Price: `;
                if (netPrice !== displayedDiscountedPrice) { // Compare rounded values
                    priceDisplay += `<span class="original-price" style="text-decoration: line-through; color: #888;">₹${netPrice}</span> <span class="discounted-price">₹${displayedDiscountedPrice}</span>`;
                } else {
                    priceDisplay += `₹${netPrice}`;
                }

                let discountText = '';
                if (originalItem.discountType === '%' && typeof originalItem.discountValue === 'number' && originalItem.discountValue !== null) {
                    discountText = `(${originalItem.discountValue}% Off)`;
                } else if (originalItem.discountType === 'flat' && typeof originalItem.discountValue === 'number' && originalItem.discountValue !== null) {
                    discountText = `(₹${originalItem.discountValue} Off)`;
                } else if (originalItem.otherDiscountText) {
                    discountText = `(${originalItem.otherDiscountText})`;
                }

                const listItem = document.createElement('li');
                listItem.innerHTML = `
                    <span>${item.name} (x${item.quantity}${item.unit ? ` ${item.unit}` : ''}) ${discountText}</span>
                    <span>${priceDisplay} ${basePriceUnit ? `per ${basePriceUnit}` : 'each'}</span>
                    <span>Subtotal: ₹${itemTotal}</span>
                    <button class="remove-item-button" data-item-id="${item._id}">Remove</button>
                `;
                orderItemsList.appendChild(listItem);
            });
            orderTotalDisplay.textContent = `Total: ₹${Math.round(total)}`;

            // Show summary and hide other sections
            orderSummaryDiv.style.display = 'flex';
            mainContentDiv.style.display = 'none';
            checkoutFormDiv.style.display = 'none';
            finalOrderDetailsDiv.style.display = 'none';

            // Add event listeners for remove buttons (delegation not needed here as list is re-rendered)
            document.querySelectorAll('.remove-item-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const itemIdToRemove = event.target.dataset.itemId;
                    removeItemFromOrder(itemIdToRemove);
                });
            });
        }
        function removeItemFromOrder(itemId) {
            delete selectedItems[itemId]; // Remove from selectedItems object

            // Find the corresponding checkbox and reset its state
            const checkbox = document.getElementById(`item-${itemId}`);
            if (checkbox) {
                checkbox.checked = false;
                const itemCard = checkbox.closest('.item-card');
                const quantityInput = itemCard.querySelector(`#quantity-${itemId}`);
                const unitSelect = itemCard.querySelector(`#unit-${itemId}`);
                const feedbackInput = itemCard.querySelector(`.feedback-input`);
                const likeButton = itemCard.querySelector('.like-button');
                const submitFeedbackButton = itemCard.querySelector('.submit-feedback-button');
                const ratingInputs = itemCard.querySelectorAll(`.star-rating input[name="rating-${itemId}"]`);
                
                // Disable all inputs and remove selected/flipped classes
                itemCard.classList.remove('selected', 'flipped-feedback', 'flipped-description');
                quantityInput.disabled = true;
                if (unitSelect) unitSelect.disabled = true;
                if (feedbackInput) {
                    feedbackInput.disabled = true;
                    feedbackInput.value = ''; // Clear feedback
                }
                if (likeButton) {
                    likeButton.disabled = true;
                    likeButton.textContent = 'Like'; // Reset like button text
                    likeButton.classList.remove('liked'); // Remove liked class
                }
                if (submitFeedbackButton) submitFeedbackButton.disabled = true;
                ratingInputs.forEach(input => input.disabled = true);
                ratingInputs.forEach(input => input.checked = false); // Clear rating
            }
            displaySelectedItems(); // Re-render order summary
            filterItems(); // Re-render main item list (to reflect deselection visually)
            updateViewSelectedItemsButtonState(); // Update main button state
        }
        /**
         * Fetches the shop's payment details (UPI ID and QR image data) from the backend.
         * @param {string} userId - The ID of the shop owner.
         */
        async function fetchShopPaymentDetails() {
            shopUpiIdDisplay.textContent = 'Loading...';
            qrCodeImage.src = 'https://placehold.co/200x200/CCCCCC/000000?text=Loading...'; // Placeholder while loading
            try {
                const response = await fetch(`${BACKEND_URL}/userDetails?userId=${userId}`);
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error fetching user details! status: ${response.status}, body: ${errorText}`);
                }
                const userData = await response.json(); // Changed to response.json()
                if (userData) {
                    // For UPI ID (text)
                    if (userData.upiId) {
                        shopUpiId = userData.upiId;
                        shopUpiIdDisplay.textContent = shopUpiId;
                    } else {
                        shopUpiIdDisplay.textContent = 'N/A (Not set)';
                        console.warn('Shop UPI ID not found for this user.');
                    }

                    // For QR Code (image data)
                    // The backend is sending the full data URL string directly in userData.imageData
                    if (userData.imageData && typeof userData.imageData === 'string' && userData.imageData.length > 0) {
                        shopQrImageData = userData.imageData; // Directly assign the full data URL string
                        qrCodeImage.src = shopQrImageData; // Set the src directly
                        console.log("QR Code image data loaded successfully.");
                    } else {
                        qrCodeImage.src = 'https://placehold.co/200x200/CCCCCC/000000?text=QR+Not+Set';
                        console.warn('Shop QR image data not found or invalid for this user.');
                    }
                } else {
                    shopUpiIdDisplay.textContent = 'N/A (User Data Missing)';
                    qrCodeImage.src = 'https://placehold.co/200x200/CCCCCC/000000?text=QR+Not+Set';
                    showMessage('Shop user details not found. Cannot load payment info.');
                }
            } catch (error) {
                console.error('Error fetching shop payment details:', error);
                shopUpiIdDisplay.textContent = 'Error loading UPI ID';
                qrCodeImage.src = 'https://placehold.co/200x200/CCCCCC/000000?text=Error';
                showMessage('Failed to load shop payment details. Please try again later.');
            }
        }

        /**
         * Places the final order by sending selected items and customer details to the backend.
         */
       /*
 * IMPORTANT: You need to add the Razorpay script to your index.html <head> or <body>:
 * <script src="https://checkout.razorpay.com/v1/checkout.js">>
 */

// Global constant (or fetch it from your server on load)
const CLIENT_RAZORPAY_KEY_ID = 'YOUR_RAZORPAY_KEY_ID'; 

// Function to handle the final submission to the server, now internal to placeOrder
async function submitFinalOrder(orderData) {
    console.log('Final Order Data being sent to server:', orderData); // Final check before sending

    try {
        // NOTE: If you are using the two-step server process from the previous answer, 
        // this is ONLY used for 'cash' or 'scanqr' methods now.
        const response = await fetch(`${BACKEND_URL}/placeOrder`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(orderData),
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP error! status: ${response.status}, body: ${errorText}`);
        }

        const responseData = await response.json();
        console.log('Order placed successfully (Server Response):', responseData);
        
        // --- Display Success and Cleanup ---
        finalOrderData = responseData;
        
        // Update final order details display (as per your existing logic)
        finalCustomerNameDisplay.textContent = responseData.customerName;
        finalCustomerContactDisplay.textContent = responseData.customerContact || 'N/A';
        finalOrderIdDisplay.textContent = `Order ID: ${responseData.orderId}`;
        
        if (responseData.estimatedDeliveryTime && responseData.estimatedTimeUnit) {
            finalEstimatedDeliveryDisplay.textContent = `Estimated Delivery: ${responseData.estimatedDeliveryTime} ${responseData.estimatedTimeUnit}`;
        } else {
            finalEstimatedDeliveryDisplay.textContent = `Estimated Delivery: N/A`;
        }
        
        // Update final order items list (as per your existing logic)
        finalOrderItemsListDiv.innerHTML = '';
        responseData.items.forEach(item => {
            // ... (Your complex price/discount calculation and display logic)
            // Re-use your existing logic for item display here
            let itemPriceDisplay = `Price: ...`; // Simplify for brevity
            let discountInfo = '...'; // Simplify for brevity
            const listItem = document.createElement('li');
            listItem.innerHTML = `${item.name} (x${item.quantity}${item.unit ? ` ${item.unit}` : ''}) ${discountInfo}
                <br>${itemPriceDisplay} | Subtotal: ₹${Math.round(item.subtotal)}`; 
            finalOrderItemsListDiv.appendChild(listItem);
        });
        
        finalOrderTotalDisplay.textContent = `Total: ₹${Math.round(responseData.totalAmount)}`;

        // Transition to final order details view
        orderSummaryDiv.style.display = 'none';
        checkoutFormDiv.style.display = 'none';
        mainContentDiv.style.display = 'none';
        finalOrderDetailsDiv.style.display = 'flex';

        selectedItems = {}; // Clear selected items after order is placed
        updateViewSelectedItemsButtonState();
        // --- End Display Success and Cleanup ---

    } catch (error) {
        console.error('Error placing order:', error);
        showMessage('Failed to place order. ' + error.message);
    }
}


// NEW: Function to initiate the Razorpay flow
async function initiateRazorpayPayment(orderData, totalAmountInPaisa) {
    try {
        // 1. Call your server to create the Razorpay Order ID (on the /api/place-order endpoint from previous answer)
        const response = await fetch('/api/place-order', { // Assumes '/api/place-order' is the correct server route
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(orderData), // Send the entire order data
        });

        const result = await response.json();

        if (!response.ok || result.error) {
            showMessage(result.error || 'Server error while initiating payment.', 'error');
            return;
        }
        
        // Server response should contain the RZP Order ID and the final amount in PAISA
        const { orderId: rzpOrderId, totalAmount: rzpAmount, keyId } = result;

        // --- RAZORPAY CHECKOUT LOGIC ---
        const options = {
            key: keyId || CLIENT_RAZORPAY_KEY_ID, 
            amount: rzpAmount, // Amount in paisa from server
            currency: "INR", 
            name: 'Your Food Shop Name', // Your Shop Name
            description: "Payment for Food Order",
            order_id: rzpOrderId, // RZP Order ID from server
            handler: async function (response) {
                // Payment Success Callback: Send verification details back to server
                const verificationResponse = await fetch('/api/verify-payment', { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        orderId: rzpOrderId, // The RZP Order ID
                        razorpayPaymentId: response.razorpay_payment_id,
                        razorpayOrderId: response.razorpay_order_id,
                        razorpaySignature: response.razorpay_signature,
                    }),
                });

                const verificationResult = await verificationResponse.json();

                if (verificationResponse.ok && !verificationResult.error) {
                    // Payment verified and order finalized on server
                    showMessage('Payment successful and order placed! Thank you.', 'success');
                    
                    // The server response (verificationResult.orderData) is the final order data
                    // Use the finalization logic from submitFinalOrder, but with the server's data
                    // NOTE: You'll need to adapt 'submitFinalOrder' if it relies on a specific server response structure.
                    // For now, we'll call a dedicated display function.
                    displayFinalOrderDetails(verificationResult.orderData);

                } else {
                    showMessage(verificationResult.error || 'Payment verification failed. Please contact support.', 'error');
                }
            },
            prefill: {
                name: orderData.customerName,
                contact: orderData.customerContact,
                // Assuming email is not mandatory, if it is, add it here
            },
            theme: {
                color: "#007bff"
            }
        };

        const rzp = new Razorpay(options);
        rzp.on('payment.failed', function (response){
            console.error('Payment failed:', response.error.description);
            showMessage('Payment failed. Reason: ' + response.error.description, 'error');
        });

        rzp.open();
    } catch (error) {
        console.error('Client-side error during Razorpay initiation:', error);
        showMessage('A network error occurred or the server is unreachable for payment initiation.', 'error');
    }
}


// ORIGINAL FUNCTION MODIFIED
async function placeOrder() {
    // 1. --- Input Validation (UNCHANGED) ---
    if (!userId || userId.trim() === '') {
        showMessage('User ID is missing from the URL. Please ensure you are accessing the app via a valid link.');
        console.error('Debug: userId is missing.', { userId, customerName, customerContact, selectedItems });
        return;
    }
    if (!customerName || customerName.trim() === '') {
        showMessage('Customer name is missing. Please restart the order process and provide your name.');
        console.error('Debug: customerName is missing.', { userId, customerName, customerContact, selectedItems });
        return;
    }
    if (!customerContact || customerContact.trim() === '') {
        showMessage('Customer contact is missing. Please restart the order process and provide your contact.');
        console.error('Debug: customerContact is missing.', { userId, customerName, customerContact, selectedItems });
        return;
    }
    if (Object.keys(selectedItems).length === 0) {
        showMessage('Your order is empty. Please select some items first.');
        console.error('Debug: selectedItems is empty.', { userId, customerName, customerContact, selectedItems });
        return;
    }

    const paymentMethod = paymentMethodSelect.value;
    let transactionId = null; 
    let finalOrderTotal = 0;
    
    // 2. --- Calculate Order Items and Total (UNCHANGED) ---
    const orderItems = Object.keys(selectedItems).map(itemId => {
        const item = selectedItems[itemId];
        const originalItem = allItems.find(i => i._id === itemId);

        if (!originalItem) {
            console.error(`Original item data not found for itemId: ${itemId}`);
            return null;
        }

        const itemTotal = calculateItemSubtotal(originalItem, item.quantity, item.unit);
        finalOrderTotal += itemTotal;

        // Determine if subscription was applied for this specific item's price calculation (UNCHANGED)
        let subscriptionAppliedForThisItem = false;
        let priceAfterRangeIncrement = typeof originalItem.price === 'number' ? originalItem.price : 0;
        priceAfterRangeIncrement += calculatePriceIncrementBasedOnRange(originalItem.price);

        if (hasShopSubscription && shopSubscriptionExpiryDate && new Date() < shopSubscriptionExpiryDate) {
            const subscriptionIncrement = calculateSubscriptionPriceIncrementFrontend(priceAfterRangeIncrement); 
            if (subscriptionIncrement > 0) {
                subscriptionAppliedForThisItem = true; 
            }
        }

        return {
            itemId: itemId,
            name: item.name,
            quantity: item.quantity,
            unit: item.unit || null,
            originalPrice: originalItem.price,
            priceBeforeDiscount: Math.round(priceAfterRangeIncrement), 
            discountType: originalItem.discountType,
            discountValue: originalItem.discountValue,
            otherDiscountText: originalItem.otherDiscountText,
            tags: originalItem.tags || [],
            feedback: item.feedback || '',
            liked: item.liked || false,
            rating: item.rating || null,
            subtotal: itemTotal, 
            subscriptionApplied: subscriptionAppliedForThisItem 
        };
    }).filter(Boolean); 

    if (orderItems.length === 0) {
        showMessage('No valid items found in your selection. Please re-select items.');
        console.error('Debug: orderItems is empty after processing selectedItems.', { selectedItems, orderItems });
        return;
    }

    finalOrderTotal = Math.round(finalOrderTotal); // Round the total amount

    const orderData = {
        userId: userId,
        customerName: customerName,
        customerContact: customerContact,
        items: orderItems,
        totalAmount: finalOrderTotal, 
        paymentMethod: paymentMethod,
        transactionId: null // Transaction ID is ONLY sent for 'scanqr' or via RZP verification
    };

    // 3. --- Payment Method Split ---
    if (paymentMethod === 'online') {
        // A. RAZORPAY FLOW: Initiate payment, server will create order
        await initiateRazorpayPayment(orderData, finalOrderTotal * 100); // Pass amount in PAISA
        return; // Exit here, the payment flow handles the final submission
    } 
    
    // B. NON-RAZORPAY FLOW: Validate and submit directly to the old /placeOrder endpoint

    // Handle 'scanqr' validation (your existing logic)
    if (paymentMethod === 'scanqr') {
        // You'll need to update your client to manage `isPaymentConfirmed` or remove it
        // as the RZP flow is the secure way for 'online' payments.
        // For 'scanqr', we must rely on the user input.
        transactionId = qrTransactionIdInput.value.trim(); 
        // Assuming isPaymentConfirmed is a global flag set when the user confirms scan/QR payment
        if (!isPaymentConfirmed || !transactionId) { 
            showMessage('Please confirm your QR payment and enter the Transaction ID.');
            return;
        }
        orderData.transactionId = transactionId;
    } 
    
    // C. FINAL SUBMISSION (for 'cash' and 'scanqr')
    await submitFinalOrder(orderData);
}

        /**
         * Displays a custom modal message to the user.
         * @param {string} message - The message to display.
         * @returns {void}
         */
        function showMessage(message) {
            const messageBox = document.createElement('div');
            messageBox.style.position = 'fixed';
            messageBox.style.top = '50%';
            messageBox.style.left = '50%';
            messageBox.style.transform = 'translate(-50%, -50%)';
            messageBox.style.backgroundColor = '#333';
            messageBox.style.color = '#fff';
            messageBox.style.padding = '20px';
            messageBox.style.borderRadius = '8px';
            messageBox.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
            messageBox.style.zIndex = '9999';
            messageBox.style.textAlign = 'center';
            messageBox.style.maxWidth = '80%';
            messageBox.style.minWidth = '250px';
            messageBox.style.fontSize = '1.1em';

            const messageText = document.createElement('p');
            messageText.textContent = message;
            messageText.style.marginBottom = '15px';

            const closeButton = document.createElement('button');
            closeButton.textContent = 'OK';
            closeButton.style.backgroundColor = '#007bff';
            closeButton.style.color = 'white';
            closeButton.style.border = 'none';
            closeButton.style.padding = '10px 20px';
            closeButton.style.borderRadius = '5px';
            closeButton.style.cursor = 'pointer';
            closeButton.style.fontSize = '1em';
            closeButton.addEventListener('click', () => {
                document.body.removeChild(messageBox); // Remove message box when OK is clicked
            });
            messageBox.appendChild(messageText);
            messageBox.appendChild(closeButton);
            document.body.appendChild(messageBox);
        }
        async function submitFeedback(itemId) {
            const itemCard = document.getElementById(`item-${itemId}`).closest('.item-card');
            const feedbackText = itemCard.querySelector('.feedback-input').value.trim();
            const likeButton = itemCard.querySelector('.like-button');
            const isLiked = likeButton.classList.contains('liked');
            const ratingInput = itemCard.querySelector(`.star-rating input[name="rating-${itemId}"]:checked`);
            const rating = ratingInput ? parseInt(ratingInput.value) : null;

            if (!feedbackText && !isLiked && !rating) {
                showMessage('Please provide some feedback (text, like, or rating) before submitting.');
                return;
            }

            // Update the selectedItems state with the latest feedback
            if (selectedItems[itemId]) {
                selectedItems[itemId].feedback = feedbackText;
                selectedItems[itemId].liked = isLiked;
                selectedItems[itemId].rating = rating;
            }

            const feedbackData = {
                userId: userId, // The shop owner's userId
                itemId: itemId,
                customerName: customerName, // The customer's name (from initial input)
                comment: feedbackText,
                liked: isLiked,
                rating: rating
            };

            try {
                const response = await fetch(`${BACKEND_URL}/foodItems/${itemId}/feedback`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(feedbackData),
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to submit feedback: ${errorText}`);
                }

                const updatedItem = await response.json();
                showMessage('Feedback submitted successfully!');

                // Update the item in the local allItems array
                const itemIndex = allItems.findIndex(i => i._id === itemId);
                if (itemIndex > -1) {
                    allItems[itemIndex] = updatedItem;
                }
                
                // Re-render the specific item card to show updated feedback/rating
                const existingCard = document.getElementById(`item-${itemId}`).closest('.item-card');
                if (existingCard) {
                    // Capture current flip states
                    const wasFeedbackFlipped = existingCard.classList.contains('flipped-feedback');
                    const wasDescriptionFlipped = existingCard.classList.contains('flipped-description');
                    const wasFeedbackInputActive = existingCard.querySelector('.back-feedback').classList.contains('show-input-face');

                    const tempDiv = document.createElement('div');
                    renderSingleItem(tempDiv, updatedItem); // Re-render the item
                    const newCard = tempDiv.firstChild;

                    existingCard.replaceWith(newCard); // Replace old card with new one

                    // Restore the visual state of the new card based on the old card's state
                    if (wasFeedbackFlipped) {
                        newCard.classList.add('flipped-feedback');
                        const backFeedbackDiv = newCard.querySelector('.back-feedback');
                        if (backFeedbackDiv && wasFeedbackInputActive) {
                            backFeedbackDiv.classList.add('show-input-face');
                        }
                    } else if (wasDescriptionFlipped) {
                        newCard.classList.add('flipped-description');
                    }
                    // No need to call attachDelegatedEventListenersForCard here,
                    // as events are handled by delegation on itemsListDiv.
                }

            } catch (error) {
                console.error('Error submitting feedback:', error);
                showMessage('Error submitting feedback: ' + error.message);
            }
        }
        function attachDelegatedEventListeners() {
            if (!itemsListDiv._delegatedListenersAttached) {
                itemsListDiv.addEventListener('change', handleItemsListChange);
                itemsListDiv.addEventListener('click', handleItemsListClick);
                itemsListDiv._delegatedListenersAttached = true;
            }
            updateCarouselNavButtons();
        }

        /**
         * Displays the order receipt in a modal.
         */
        function displayReceipt() {
            if (!finalOrderData) {
                showMessage('No order data available for receipt.');
                return;
            }

            let itemsHtml = '';
            let totalQuantityOrdered = 0;
            let totalQuantityCharged = 0;

            finalOrderData.items.forEach(item => {
                let priceBeforeDiscountAndRounding = typeof item.originalPrice === 'number' ? item.originalPrice : 0;
                // If the backend already provided priceBeforeDiscount (after subscription and range increment), use it
                if (item.priceBeforeDiscount && typeof item.priceBeforeDiscount === 'number') {
                    priceBeforeDiscountAndRounding = item.priceBeforeDiscount;
                } else { // Fallback: re-calculate if backend doesn't provide it
                    priceBeforeDiscountAndRounding += calculatePriceIncrementBasedOnRange(item.originalPrice);
                    if (hasShopSubscription && shopSubscriptionExpiryDate && new Date() < shopSubscriptionExpiryDate) {
                        priceBeforeDiscountAndRounding += calculateSubscriptionPriceIncrementFrontend(item.originalPrice);
                    }
                }
                const netPrice = Math.round(priceBeforeDiscountAndRounding);
                
                let calculatedDiscountedPrice = netPrice;
                if (item.discountType === '%' && typeof item.discountValue === 'number' && item.discountValue !== null) {
                    calculatedDiscountedPrice = netPrice * (1 - item.discountValue / 100);
                } else if (item.discountType === 'flat' && typeof item.discountValue === 'number' && item.discountValue !== null) {
                    calculatedDiscountedPrice = netPrice - item.discountValue;
                    if (calculatedDiscountedPrice < 0) calculatedDiscountedPrice = 0;
                }
                const finalItemPrice = Math.round(calculatedDiscountedPrice);

                let itemPriceDisplay = `Price: `;
                let discountInfo = '';

                if (netPrice !== finalItemPrice) {
                    itemPriceDisplay += `<span class="original-price" style="text-decoration: line-through; color: #888;">₹${netPrice}</span> <span class="discounted-price">₹${finalItemPrice}</span>`;
                } else {
                    itemPriceDisplay += `₹${netPrice}`;
                }
                
                if (item.discountType === '%' && typeof item.discountValue === 'number' && item.discountValue !== null) {
                    discountInfo = `(-${item.discountValue}%)`;
                } else if (item.discountType === 'flat' && typeof item.discountValue === 'number' && item.discountValue !== null) {
                    discountInfo = `(-₹${item.discountValue})`;
                } else if (item.otherDiscountText) {
                    const buyNGetMFreeDetails = parseBuyNGetMFree(item.otherDiscountText);
                    if (buyNGetMFreeDetails) {
                        const { buyQuantity, getQuantity } = buyNGetMFreeDetails;
                        const freeUnits = Math.floor(item.quantity / buyQuantity) * getQuantity;
                        if (freeUnits > 0) {
                            // Display charged quantity for "Buy N Get M Free"
                            discountInfo = `(${item.otherDiscountText} - Charged for ${item.effectiveQuantity}${item.unit ? ` ${item.unit}` : ''})`;
                        } else {
                            discountInfo = `(${item.otherDiscountText})`;
                        }
                    } else {
                        discountInfo = `(${item.otherDiscountText})`;
                    }
                } else if (item.subscriptionApplied) { // Check if subscription was applied for this item (from backend response)
                    discountInfo = `(Subscr. Adj.)`;
                }

                itemsHtml += `
                    <li>
                        ${item.name} (Qty: ${item.quantity}${item.unit ? ` ${item.unit}` : ''}) ${discountInfo}
                        <br>${itemPriceDisplay} | Subtotal: ₹${Math.round(item.subtotal)}
                    </li>
                `;
                totalQuantityOrdered += item.quantity;
                totalQuantityCharged += (typeof item.effectiveQuantity === 'number' ? item.effectiveQuantity : item.quantity); // Use effectiveQuantity if available, else ordered quantity
            });

            receiptContent.innerHTML = `
                <p><strong>Order ID:</strong> ${finalOrderData.orderId}</p>
                <p><strong>Customer Name:</strong> ${finalOrderData.customerName || 'N/A'}</p>
                <p><strong>Customer Contact:</strong> ${finalOrderData.customerContact || 'N/A'}</p>
                <p><strong>Payment Mode:</strong> ${finalOrderData.paymentMethod === 'cash' ? 'Cash on Delivery' : (finalOrderData.paymentMethod === 'online' ? 'Online (UPI)' : 'Scan QR')}</p>
                <p><strong>Transaction ID:</strong> ${finalOrderData.transactionId || 'N/A'}</p>
                <p><strong>Total Items Quantity (Ordered):</strong> ${totalQuantityOrdered}</p>
                <p><strong>Total Items Quantity (Charged):</strong> ${totalQuantityCharged.toFixed(3)}</p>
                <h3>Ordered Items:</h3>
                <ul>${itemsHtml}</ul>
                <p class="receipt-total"><strong>Total Amount: ₹${Math.round(finalOrderData.totalAmount)}</strong></p>
                <p style="text-align: center; margin-top: 20px; font-style: italic;">Thank you for your order!</p>
            `;
            receiptModal.style.display = 'flex'; // Show the receipt modal
        }
        // --- Carousel Navigation Functions ---

        /**
         * Scrolls the items carousel to a specific item index.
         * @param {number} index - The index of the item to scroll to.
         */
        function scrollToItem(index) {
            const items = itemsListDiv.children;
            if (items.length === 0) {
                currentCarouselIndex = 0;
                return;
            }
            if (index < 0) index = 0; // Prevent scrolling before first item
            if (index >= items.length) index = items.length - 1; // Prevent scrolling past last item

            currentCarouselIndex = index;
            const targetItem = items[currentCarouselIndex];
            if (targetItem) {
                itemsListDiv.scrollTo({
                    left: targetItem.offsetLeft - (itemsListDiv.offsetWidth / 2) + (targetItem.offsetWidth / 2),
                    behavior: 'smooth'
                });
            }
            updateCarouselNavButtons(); // Update button states after scroll
        }
        /**
         * Updates the disabled state of the carousel navigation buttons.
         */
        function updateCarouselNavButtons() {
            const items = itemsListDiv.children;
            prevItemButton.disabled = currentCarouselIndex === 0 || items.length === 0;
            nextItemButton.disabled = currentCarouselIndex >= (items.length - 1) || items.length === 0;
        }
        function handleScrollSnap() {
            const scrollLeft = itemsListDiv.scrollLeft;
            const items = itemsListDiv.children;
            if (items.length === 0) return;

            let closestIndex = 0;
            let minDiff = Infinity;

            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                const itemCenter = item.offsetLeft + (item.offsetWidth / 2);
                const viewportCenter = scrollLeft + (itemsListDiv.offsetWidth / 2);
                const diff = Math.abs(itemCenter - viewportCenter);

                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }
            }
            if (currentCarouselIndex !== closestIndex) {
                currentCarouselIndex = closestIndex;
                updateCarouselNavButtons();
            }
        }

        // --- Desktop Mode Prompt Functions (for mobile devices) ---

        /**
         * Checks if the current device is likely a mobile device.
         * @returns {boolean} True if likely mobile, false otherwise.
         */
        function isMobileDevice() {
            return window.innerWidth < 768; // Common breakpoint for mobile
        }

        /**
         * Shows the desktop mode prompt modal if on a mobile device.
         */
        function showDesktopModePrompt() {
            if (isMobileDevice()) {
                mobilePromptModal.style.display = 'flex';
            }
        }

        /**
         * Switches the viewport meta tag to simulate desktop mode.
         */
        function switchToDesktopMode() {
            const viewportMeta = document.querySelector('meta[name="viewport"]');
            if (viewportMeta) {
                viewportMeta.setAttribute('content', 'width=1200'); // A fixed width larger than mobile
            }
            mobilePromptModal.style.display = 'none'; // Hide the modal after switching
        }

        // --- Event Listeners & Initializations ---

        // Event listener for the initial customer name entry form
        startOrderingButton.addEventListener('click', () => {
            customerName = initialCustomerNameInput.value.trim();
            customerContact = customerContactInput.value.trim();

            if (customerName && customerContact) {
                customerNameEntryDiv.style.display = 'none';
                mainContentDiv.style.display = 'flex'; // Show main content
                // Ensure userId is correctly set by getUrlParameters() before this call
                fetchShopInstructions(); // Fetch shop instructions once name is entered
                initialLoadItems(); // Load food items only after customer details are captured
                showDesktopModePrompt(); // Prompt for desktop mode on mobile after content loads
            } else {
                nameEntryErrorDiv.style.display = 'block';
            }
        });

        // Event listeners for filters
        searchInput.addEventListener('input', filterItems);
        categorySelect.addEventListener('change', filterItems);
        mainCategorySelect.addEventListener('change', filterItems); // NEW: Event listener for main category
        ratingFilterSelect.addEventListener('change', filterItems);

        // Event listener for "View Selected Items" button
        viewSelectedItemsButton.addEventListener('click', displaySelectedItems);

        // Event listener for "Proceed to Checkout" button
        proceedToCheckoutButton.addEventListener('click', () => {
            checkoutCustomerNameDisplay.textContent = customerName;
            checkoutCustomerContactDisplay.textContent = customerContact;
            paymentMethodSelect.value = 'cash'; // Default to cash on entering checkout
            upiDetailsSection.style.display = 'none'; // Hide UPI by default
            qrDetailsSection.style.display = 'none'; // Hide QR by default
            isPaymentConfirmed = false; // Reset payment confirmation
            transactionIdDisplay.textContent = 'N/A'; // Clear transaction ID
            qrTransactionIdInput.value = '';
            
            checkoutFormDiv.style.display = 'flex'; // Show checkout form
            orderSummaryDiv.style.display = 'none'; // Hide order summary

            fetchShopPaymentDetails(); // Fetch payment details when checkout is opened
        });

        // Event listener for payment method selection
        paymentMethodSelect.addEventListener('change', (event) => {
            const selectedMethod = event.target.value;
            upiDetailsSection.style.display = 'none';
            qrDetailsSection.style.display = 'none';
            isPaymentConfirmed = false; // Reset confirmation on method change
            transactionIdDisplay.textContent = 'N/A';
            qrTransactionIdInput.value = '';

            if (selectedMethod === 'online') {
                upiDetailsSection.style.display = 'block';
            } else if (selectedMethod === 'scanqr') {
                qrDetailsSection.style.display = 'block';
            }
        });

        // Event listener for Copy UPI ID button
        copyUpiIdButton.addEventListener('click', () => {
            if (shopUpiId) {
                document.execCommand('copy'); // Fallback for older browsers
                const tempInput = document.createElement('textarea');
                tempInput.value = shopUpiId;
                document.body.appendChild(tempInput);
                tempInput.select();
                document.execCommand('copy');
                document.body.removeChild(tempInput);
                showMessage('UPI ID copied to clipboard!');
            } else {
                showMessage('No UPI ID available to copy.');
            }
        });
        
        // Event listeners for UPI app buttons
        payWithPhonePeButton.addEventListener('click', () => {
            if (shopUpiId) {
                // Construct PhonePe deep link
                const amount = Math.round(Object.values(selectedItems).reduce((sum, item) => sum + calculateItemSubtotal(allItems.find(i => i._id === item._id), item.quantity, item.unit), 0));
                const url = `phonepe://pay?pa=${shopUpiId}&pn=ShopOwner&mc=1234&tid=T${Date.now()}&tr=TR${Date.now()}&am=${amount}.00&cu=INR&url=https://www.yourshop.com/order-success`;
                window.location.href = url;
                // For demonstration, directly show a transaction ID and confirm payment
                transactionIdDisplay.textContent = `PHE${Date.now()}`;
                isPaymentConfirmed = true;
                showMessage('Redirecting to PhonePe. Please complete payment and confirm here.');
            } else {
                showMessage('Shop UPI ID not available.');
            }
        });

        payWithGPayButton.addEventListener('click', () => {
            if (shopUpiId) {
                // Construct GPay deep link
                const amount = Math.round(Object.values(selectedItems).reduce((sum, item) => sum + calculateItemSubtotal(allItems.find(i => i._id === item._id), item.quantity, item.unit), 0));
                const url = `tez://upi/pay?pa=${shopUpiId}&pn=ShopOwner&mc=1234&tid=T${Date.now()}&tr=TR${Date.now()}&am=${amount}.00&cu=INR&url=https://www.yourshop.com/order-success`;
                window.location.href = url;
                // For demonstration, directly show a transaction ID and confirm payment
                transactionIdDisplay.textContent = `GPY${Date.now()}`;
                isPaymentConfirmed = true;
                showMessage('Redirecting to GPay. Please complete payment and confirm here.');
            } else {
                showMessage('Shop UPI ID not available.');
            }
        });

        payWithPaytmButton.addEventListener('click', () => {
            if (shopUpiId) {
                const amount = Math.round(Object.values(selectedItems).reduce((sum, item) => sum + calculateItemSubtotal(allItems.find(i => i._id === item._id), item.quantity, item.unit), 0));
                const url = `paytmmp://pay?pa=${shopUpiId}&pn=ShopOwner&mc=1234&tid=T${Date.now()}&tr=TR${Date.now()}&am=${amount}.00&cu=INR&url=https://www.yourshop.com/order-success`;
                window.location.href = url;
                transactionIdDisplay.textContent = `PTM${Date.now()}`;
                isPaymentConfirmed = true;
                showMessage('Redirecting to Paytm. Please complete payment and confirm here.');
            } else {
                showMessage('Shop UPI ID not available.');
            }
        });

        confirmPaymentButton.addEventListener('click', () => {
            if (transactionIdDisplay.textContent && transactionIdDisplay.textContent !== 'N/A') {
                isPaymentConfirmed = true;
                showMessage('Payment confirmed! You can now place your order.');
            } else {
                showMessage('Please initiate payment through an app first to get a transaction ID.');
            }
        });

        confirmQrPaymentButton.addEventListener('click', () => {
            if (qrTransactionIdInput.value.trim()) {
                isPaymentConfirmed = true;
                showMessage('QR Payment transaction ID recorded. You can now place your order.');
            } else {
                showMessage('Please enter the transaction ID after scanning and paying.');
            }
        });

        // Event listener for "Place Order" button
        placeFinalOrderButton.addEventListener('click', placeOrder);

        // Event listener for "View Receipt" button
        viewReceiptButton.addEventListener('click', displayReceipt);

        // Modal close buttons
        feedbackModalClose.addEventListener('click', () => {
            feedbackModal.style.display = 'none';
        });
        receiptModalClose.addEventListener('click', () => {
            receiptModal.style.display = 'none';
        });
        window.addEventListener('click', (event) => {
            if (event.target === feedbackModal) {
                feedbackModal.style.display = 'none';
            }
            if (event.target === receiptModal) {
                receiptModal.style.display = 'none';
            }
            if (event.target === mobilePromptModal) {
                mobilePromptModal.style.display = 'none';
            }
        });

        // Download receipt button
        downloadReceiptButton.addEventListener('click', () => {
            if (!finalOrderData) {
                showMessage('No order data to generate receipt.');
                return;
            }
            const receiptHtml = receiptContent.innerHTML;
            const blob = new Blob([receiptHtml], { type: 'text/html' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `receipt_${finalOrderData.orderId || 'order'}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href); // Clean up
            showMessage('Receipt downloaded successfully!');
        });

        // Carousel navigation buttons
        prevItemButton.addEventListener('click', () => scrollToItem(currentCarouselIndex - 1));
        nextItemButton.addEventListener('click', () => scrollToItem(currentCarouselIndex + 1));
        itemsListDiv.addEventListener('scroll', handleScrollSnap);

        // Touch events for carousel swipe
        itemsListDiv.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
        });

        itemsListDiv.addEventListener('touchmove', (e) => {
            // Prevent vertical scrolling while horizontal swiping
            if (Math.abs(e.touches[0].clientX - touchStartX) > 10) {
                e.preventDefault();
            }
        });

        itemsListDiv.addEventListener('touchend', (e) => {
            const touchEndX = e.changedTouches[0].clientX;
            const diff = touchStartX - touchEndX; // positive for left swipe, negative for right

            if (diff > 50) { // Swiped left
                scrollToItem(currentCarouselIndex + 1);
            } else if (diff < -50) { // Swiped right
                scrollToItem(currentCarouselIndex - 1);
            }
        });

        // Desktop mode prompt button
        switchToDesktopButton.addEventListener('click', switchToDesktopMode);
        // Removed noThanksButton listener
    </script>
    <script src="https://checkout.razorpay.com/v1/checkout.js"></script>
</body>
</html>